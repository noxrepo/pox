# Copyright 2011,2012 James McCauley
#
# This file is part of POX.
#
# POX is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# POX is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with POX.  If not, see <http://www.gnu.org/licenses/>.

# This file was originally based on pyopenflow.py from NOX, which was
# autogenerated from openflow.h via a program by KK Yap.  It has been
# substantially altered since then.

import struct
import operator
import collections
from itertools import chain, repeat
import sys
from pox.lib.packet.packet_base import packet_base
from pox.lib.packet.ethernet import ethernet
from pox.lib.packet.vlan import vlan
from pox.lib.packet.ipv4 import ipv4
from pox.lib.packet.udp import udp
from pox.lib.packet.tcp import tcp
from pox.lib.packet.icmp import icmp
from pox.lib.packet.arp import arp

from pox.lib.addresses import *
from pox.lib.util import assert_type
from pox.lib.util import initHelper
from pox.lib.util import hexdump


EMPTY_ETH = EthAddr(None)

# ----------------------------------------------------------------------
# XID Management
# ----------------------------------------------------------------------

MAX_XID = 0x7fFFffFF


def XIDGenerator (start = 1, stop = MAX_XID):
  i = start
  while True:
    yield i
    i += 1
    if i > stop:
      i = start

def xid_generator (start = 1, stop = MAX_XID):
  return XIDGenerator(start, stop).next

def user_xid_generator ():
  return xid_generator(0x80000000, 0xffFFffFF)

generate_xid = xid_generator()

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# Packing / Unpacking
# ----------------------------------------------------------------------

_PAD = b'\x00'
_PAD2 = _PAD*2
_PAD3 = _PAD*3
_PAD4 = _PAD*4
_PAD6 = _PAD*6

class UnderrunError (RuntimeError):
  """
  Raised when one tries to unpack more data than is available
  """
  pass

def _read (data, offset, length):
  if (len(data)-offset) < length: raise UnderrunError()
  return (offset+length, data[offset:offset+length])

def _unpack (data, offset, fmt):
  size = struct.calcsize(fmt)
  if (len(data)-offset) < size: raise UnderrunError()
  return (offset+size, struct.unpack___from(fmt, data, offset))

def _skip (data, offset, num):
  offset += num
  if offset > len(data): raise UnderrunError()
  return offset

def _unpad (data, offset, num):
  (offset, o) = _read(data, offset, num)
  assert len(o.replace("\x00", "")) == 0
  return offset

def _readzs (data, offset, length):
  (offset, d) = _read(data, offset, length)
  d = d.split("\x00", 1)
  assert len(d[1].replace("\x00", "")) == 0
  #if len(d[1].replace("\x00", "")) > 0:
  #  raise RuntimeError("Non-zero string padding")
  return (offset, d[0])

def _readether (data, offset):
  (offset, d) = _read(data, offset, 6)
  return (offset, EthAddr(d))

def _readip (data, offset):
  (offset, d) = _read(data, offset, 4)
  return (offset, IPAddr(d))

# ----------------------------------------------------------------------


def _format_body (body, prefix):
  if hasattr(body, 'show'):
    #TODO: Check this (spacing may well be wrong)
    return body.show(prefix + '  ')
  else:
    return prefix + hexdump(body).replace("\n", "\n" + prefix)

TABLE_ALL = 0xff
TABLE_EMERGENCY = 0xfe


class _ofp_meta (type):
  """
  Metaclass for ofp messages/structures

  This takes care of making len() work as desired.
  """
  def __len__ (cls):
    try:
      return cls.__len__()
    except:
      return cls._MIN_LENGTH


class ofp_base (object):
  """
  Base class for OpenFlow messages/structures

  You should implement a __len__ method.  If your length is fixed, it
  should be a static method.  If your length is not fixed, you should
  implement a __len__ instance method and set a class level _MIN_LENGTH
  attribute to your minimum length.
  """
  __metaclass__ = _ofp_meta

  def _assert (self):
    r = self._validate()
    if r is not None:
      raise RuntimeError(r)
      return False # Never reached
    return True

  def _validate (self):
    return None

  @classmethod
  def unpack_new (cls, raw, offset=0):
    assert offset == 0 # Not implemented yet
    o = cls()
    r = o.unpack(raw)#, offset)
    return (r, o)


# ----------------------------------------------------------------------
# Class decorators
# ----------------------------------------------------------------------

_message_type_to_class = {}
_message_class_to_types = {} # Do we need this?
#_message_type_to_name = {}
#_message_name_to_type = {}
ofp_type_rev_map = {}
ofp_type_map = {}

def openflow_message (ofp_type, type_val, reply_to=None,
    request_for=None, switch=False, controller=False):
  #TODO: Reply stuff, switch/controller stuff

  #_message_name_to_type[ofp_type] = type_val
  #_message_type_to_name[type_val] = ofp_type
  ofp_type_rev_map[ofp_type] = type_val
  ofp_type_map[type_val] = ofp_type
  def f (c):
    c.header_type = type_val
    c._from_switch = switch
    c._from_controller = controller
    _message_type_to_class[type_val] = c
    _message_class_to_types.setdefault(c, set()).add(type_val)
    return c
  return f

def openflow_sc_message (*args, **kw):
  return openflow_message(switch=True, controller=True, *args, **kw)

def openflow_c_message (*args, **kw):
  return openflow_message(controller=True, *args, **kw)

def openflow_s_message (*args, **kw):
  return openflow_message(switch=True, *args, **kw)


_action_type_to_class = {}
_action_class_to_types = {} # Do we need this?
ofp_action_type_rev_map = {}
ofp_action_type_map = {}

def openflow_action (action_type, type_val):
  ofp_action_type_rev_map[action_type] = type_val
  ofp_action_type_map[type_val] = action_type
  def f (c):
    c.type = type_val
    _action_type_to_class[type_val] = c
    _action_class_to_types.setdefault(c, set()).add(type_val)
    return c
  return f


class _StatsClassInfo (object):
  __slots__ = 'request reply reply_is_list'.split()

  def __init__ (self, **kw):
    self.request = None
    self.reply = None
    self.reply_is_list = False
    initHelper(self, kw)

  def __str__ (self):
    r = str(self.reply)
    if self.reply_is_list: r = "[%s]" % (r,)
    return "request:%s reply:%s" % (self.request, r)

_stats_type_to_class_info = {}
_stats_class_to_type = {}
ofp_stats_type_rev_map = {}
ofp_stats_type_map = {}

def openflow_stats_request  (stats_type, type_val=None, is_list=None,
    is_reply = False):
  if type_val is not None:
    ofp_stats_type_rev_map[stats_type] = type_val
    ofp_stats_type_map[type_val] = stats_type
  else:
    type_val = ofp_stats_type_rev_map.get(stats_type)

  def f (c):
    if type_val is not None:
      ti = _stats_type_to_class_info.get(stats_type)
      if ti is not None:
        _stats_type_to_class_info[type_val] = ti
        del _stats_type_to_class_info[stats_type]
      else:
        ti = _stats_type_to_class_info.setdefault(type_val,
            _StatsClassInfo())
      _stats_class_to_type[c] = type_val
    else:
      ti = _stats_type_to_class_info.setdefault(stats_type,
          _StatsClassInfo())

    if is_list is not None:
      ti.reply_is_list = is_list
    if is_reply:
      ti.reply = c
    else:
      ti.request = c

    if type_val is not None:
      if ti.reply and issubclass(ti.reply, ofp_stats_body_base):
        ti.reply._type = type_val
      if ti.request and issubclass(ti.request, ofp_stats_body_base):
        ti.request._type = type_val

    return c
  return f

def openflow_stats_reply (stats_type, type_val=None, is_list=None,
    is_reply = True):
  return openflow_stats_request(stats_type, type_val, is_list, is_reply)

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# Constants, etc.
# ----------------------------------------------------------------------

ofp_error_type_rev_map = {
  'OFPET_HELLO_FAILED'    : 0,
  'OFPET_BAD_REQUEST'     : 1,
  'OFPET_BAD_ACTION'      : 2,
  'OFPET_FLOW_MOD_FAILED' : 3,
  'OFPET_PORT_MOD_FAILED' : 4,
  'OFPET_QUEUE_OP_FAILED' : 5,
}

ofp_hello_failed_code_rev_map = {
  'OFPHFC_INCOMPATIBLE' : 0,
  'OFPHFC_EPERM'        : 1,
}

ofp_bad_request_code_rev_map = {
  'OFPBRC_BAD_VERSION'    : 0,
  'OFPBRC_BAD_TYPE'       : 1,
  'OFPBRC_BAD_STAT'       : 2,
  'OFPBRC_BAD_VENDOR'     : 3,
  'OFPBRC_BAD_SUBTYPE'    : 4,
  'OFPBRC_EPERM'          : 5,
  'OFPBRC_BAD_LEN'        : 6,
  'OFPBRC_BUFFER_EMPTY'   : 7,
  'OFPBRC_BUFFER_UNKNOWN' : 8,
}

ofp_bad_action_code_rev_map = {
  'OFPBAC_BAD_TYPE'        : 0,
  'OFPBAC_BAD_LEN'         : 1,
  'OFPBAC_BAD_VENDOR'      : 2,
  'OFPBAC_BAD_VENDOR_TYPE' : 3,
  'OFPBAC_BAD_OUT_PORT'    : 4,
  'OFPBAC_BAD_ARGUMENT'    : 5,
  'OFPBAC_EPERM'           : 6,
  'OFPBAC_TOO_MANY'        : 7,
  'OFPBAC_BAD_QUEUE'       : 8,
}

ofp_flow_mod_failed_code_rev_map = {
  'OFPFMFC_ALL_TABLES_FULL'   : 0,
  'OFPFMFC_OVERLAP'           : 1,
  'OFPFMFC_EPERM'             : 2,
  'OFPFMFC_BAD_EMERG_TIMEOUT' : 3,
  'OFPFMFC_BAD_COMMAND'       : 4,
  'OFPFMFC_UNSUPPORTED'       : 5,
}

ofp_port_mod_failed_code_rev_map = {
  'OFPPMFC_BAD_PORT'    : 0,
  'OFPPMFC_BAD_HW_ADDR' : 1 << 0,
}

ofp_queue_op_failed_code_rev_map = {
  'OFPQOFC_BAD_PORT'  : 0,
  'OFPQOFC_BAD_QUEUE' : 1 << 0,
  'OFPQOFC_EPERM'     : 1 << 1,
}

# updated for openflow 1.1
ofp_port_config_rev_map = {
  'OFPPC_PORT_DOWN'    : 1 << 0,
  'OFPPC_NO_RECV'      : 1 << 2,
  'OFPPC_NO_FWD'       : 1 << 5,
  'OFPPC_NO_PACKET_IN' : 1 << 6,
}

# updated for openflow 1.1
ofp_port_state_rev_map = {
  'OFPPS_LINK_DOWN'   : 1 << 0,
  'OFPPS_BLOCKED'     : 1 << 1,
  'OFPPS_LIVE'        : 1 << 2,
}
#OFPPS_STP_MASK        = 768

# updated for openflow 1.1
ofp_port_features_rev_map = {
  'OFPPF_10MB_HD'    : 1 << 0,
  'OFPPF_10MB_FD'    : 1 << 1,
  'OFPPF_100MB_HD'   : 1 << 2,
  'OFPPF_100MB_FD'   : 1 << 3,
  'OFPPF_1GB_HD'     : 1 << 4,
  'OFPPF_1GB_FD'     : 1 << 5,
  'OFPPF_10GB_FD'    : 1 << 6,
  'OFPPF_40GB_FD'    : 1 << 7,
  'OFPPF_100GB_FD'   : 1 << 8,
  'OFPPF_1TB_FD'     : 1 << 9,
  'OFPPF_OTHER'      : 1 << 10,
  'OFPPF_COPPER'     : 1 << 11,
  'OFPPF_FIBER'      : 1 << 12,
  'OFPPF_AUTONEG'    : 1 << 13,
  'OFPPF_PAUSE'      : 1 << 14,
  'OFPPF_PAUSE_ASYM' : 1 << 15,
}

ofp_queue_properties_rev_map = {
  'OFPQT_MIN_RATE' : 0,
}
OFPQT_NONE         = 0

ofp_capabilities_rev_map = {
  'OFPC_FLOW_STATS'   : 1 << 0,
  'OFPC_TABLE_STATS'  : 1 << 1,
  'OFPC_PORT_STATS'   : 1 << 2,
  'OFPC_STP'          : 1 << 3,
  'OFPC_RESERVED'     : 1 << 4,
  'OFPC_IP_REASM'     : 1 << 5,
  'OFPC_QUEUE_STATS'  : 1 << 6,
  'OFPC_ARP_MATCH_IP' : 1 << 7,
}

ofp_config_flags_rev_map = {
  'OFPC_FRAG_NORMAL' : 0,
  'OFPC_FRAG_DROP'   : 1 << 0,
  'OFPC_FRAG_REASM'  : 1 << 1,
  'OFPC_FRAG_MASK'   : 3,
}

ofp_flow_mod_command_rev_map = {
  'OFPFC_ADD'           : 0,
  'OFPFC_MODIFY'        : 1,
  'OFPFC_MODIFY_STRICT' : 2,
  'OFPFC_DELETE'        : 3,
  'OFPFC_DELETE_STRICT' : 4,
}

ofp_flow_mod_flags_rev_map = {
  'OFPFF_SEND_FLOW_REM' : 1 << 0,
  'OFPFF_CHECK_OVERLAP' : 1 << 1,
  'OFPFF_EMERG'         : 1 << 2,
}

ofp_stats_reply_flags_rev_map = {
  'OFPSF_REPLY_MORE' : 1 << 0,
}

ofp_packet_in_reason_rev_map = {
  'OFPR_NO_MATCH' : 0,
  'OFPR_ACTION'   : 1 << 0,
}

ofp_flow_removed_reason_rev_map = {
  'OFPRR_IDLE_TIMEOUT' : 0,
  'OFPRR_HARD_TIMEOUT' : 1 << 0,
  'OFPRR_DELETE'       : 1 << 1,
}

ofp_port_reason_rev_map = {
  'OFPPR_ADD'    : 0,
  'OFPPR_DELETE' : 1 << 0,
  'OFPPR_MODIFY' : 1 << 1,
}

# updated for openflow 1.1

ofp_port_rev_map = {
  'OFPP_MAX'        : 0xFFFFFF00,
  'OFPP_IN_PORT'    : 0xFFFFFFF8,
  'OFPP_TABLE'      : 0xFFFFFFF9,
  'OFPP_NORMAL'     : 0xFFFFFFFA,
  'OFPP_FLOOD'      : 0xFFFFFFFB,
  'OFPP_ALL'        : 0xFFFFFFFC,
  'OFPP_CONTROLLER' : 0xFFFFFFFD,
  'OFPP_LOCAL'      : 0xFFFFFFFE,
  'OFPP_ANY'        : 0xFFFFFFFF,
}

# new in openflow 1.1

ofp_match_type_rev_map = {
  'OFPMT_STANDARD'     : 1 << 0,
}

# updated for openflow 1.1
ofp_flow_wildcards_rev_map = {
  'OFPFW_IN_PORT'      : 1 << 0,
  'OFPFW_DL_VLAN'      : 1 << 1,
  'OFPFW_DL_VLAN_PCP'  : 1 << 2,
  'OFPFW_DL_TYPE'      : 1 << 3,
  'OFPFW_NW_TOS'       : 1 << 4,
  'OFPFW_NW_PROTO'     : 1 << 5,
  'OFPFW_TP_SRC'       : 1 << 6,
  'OFPFW_TP_DST'       : 1 << 7,
  'OFPFW_MPLS_LABEL'   : 1 << 8,
  'OFPFW_MPLS_TC'      : 1 << 9,
}

# Note: Need to handle all flags that are set in this.
# glob-all masks in the packet handling methods.
# (Esp. ofp_match.from_packet)
# Otherwise, packets are not being matched as they should
OFPFW_ALL              = ((1 << 10) - 1)

NO_BUFFER = 4294967295

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# Structure definitions
# ----------------------------------------------------------------------

#1. Openflow Header
class ofp_header (ofp_base):
  def __init__ (self, **kw):
    self.version = OFP_VERSION
    #self.header_type = None # Set via class decorator
    self._xid = None
    if 'header_type' in kw:
      self.header_type = kw.pop('header_type')
    initHelper(self, kw)

  @property
  def xid (self):
    if self._xid is None:
      self._xid = generate_xid()
    return self._xid

  @xid.setter
  def xid (self, val):
    self._xid = val

  def _validate (self):
    if self.header_type not in ofp_type_map:
      return "type is not a known message type"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!BBHL", self.version, self.header_type,
        len(self), self.xid)
    return packed

  def unpack (self, binaryString):
    if len(binaryString) < 8:
      return binaryString
    #FIXME: self._length is a temporary hack
    (self.version, self.header_type, self._length, self.xid) = \
        struct.unpack_from("!BBHL", binaryString, 0)
    return binaryString[8:]

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.version != other.version: return False
    if self.header_type != other.header_type: return False
    if len(self) != len(other): return False
    if self.xid != other.xid: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'version: ' + str(self.version) + '\n'
    outstr += prefix + 'type:    ' + str(self.header_type)# + '\n'
    outstr += " (" + ofp_type_map.get(self.header_type, "Unknown") + ")\n"
    try:
      outstr += prefix + 'length:  ' + str(len(self)) + '\n'
    except:
      pass
    outstr += prefix + 'xid:     ' + str(self.xid) + '\n'
    return outstr
  
  def __str__ (self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()


class ofp_stats_body_base (ofp_base):
  """
  Base class for stats bodies
  """
  # Stats bodies don't actually have a type field in OpenFlow --
  # the type information is in the request or reply.  It's really
  # convenient, though, so we add it.  Note that you generally
  # don't need to set this yourself -- the openflow_stats_XXX
  # decorator will do it for you.
  _type = None


class ofp_action_base (ofp_base):
  """
  Base class for actions

  This is sort of the equivalent of ofp_action_header like the spec.
  However, ofp_action_header as the spec defines it is not super
  useful for us, as it has the padding in it.
  """
  type = None


#2. Common Structures
##2.1 Port Structures
# renamed from ofp_phy_port to ofp_port in openflow 1.1
class ofp_port (ofp_base):
  def __init__ (self, **kw):
    self.port_no = 0
    self.hw_addr = EMPTY_ETH
    self.name = ""
    self.config = 0
    self.state = 0
    self.curr = 0
    self.advertised = 0
    self.supported = 0
    self.peer = 0
    self.curr_speed = 0
    self.max_speed = 0
    initHelper(self, kw)

  def __str__ (self):
    return "%s:%i" % (self.name, self.port_no)

  def _validate (self):
    if (not isinstance(self.hw_addr, bytes)
        and not isinstance(self.hw_addr, EthAddr)):
      return "hw_addr is not bytes or EthAddr"
    if len(self.hw_addr) != 6:
      return "hw_addr is not of size 6"
    if not isinstance(self.name, str):
      return "name is not string"
    if len(self.name) > 16:
      return "name is not of size 16"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    # port number is uint32_t instead of uint16_t and has 4 padding bytes afterwards
    packed += struct.pack("!LL", self.port_no, 0)
    packed += self.hw_addr if isinstance(self.hw_addr, bytes) else self.hw_addr.toRaw()
    # extra 2 padding bytes
    packed += struct.pack("!H", 0)
    packed += self.name.ljust(16,'\0')
    packed += struct.pack("!LLLLLL", self.config, self.state, self.curr, self.advertised, self.supported, self.peer, self.curr_speed, self.max_speed)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 64):
      return binaryString
    (self.port_no,) = struct.unpack_from("!L", binaryString, 0)
    # 4 bytes for port no, 4 bytes padding
    self.hw_addr = EthAddr(binaryString[8:14])
    # ignore 2 padding bytes
    self.name = binaryString[16:32].replace("\0","")
    (self.config, self.state, self.curr, self.advertised, self.supported, self.peer, self.curr_speed, self.max_speed) = struct.unpack_from("!LLLLLLLL", binaryString, 32)
    return binaryString[64:]

  @staticmethod
  def __len__ ():
    return 64

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.hw_addr != other.hw_addr: return False
    if self.name != other.name: return False
    if self.config != other.config: return False
    if self.state != other.state: return False
    if self.curr != other.curr: return False
    if self.advertised != other.advertised: return False
    if self.supported != other.supported: return False
    if self.peer != other.peer: return False
    if self.curr_speed != other.curr_speed: return False
    if self.max_speed != other.max_speed: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def __cmp__ (self, other):
    if type(other) != type(self): return id(self)-id(other)
    if self.port_no < other.port_no: return -1
    if self.port_no > other.port_no: return 1
    if self == other: return 0
    return id(self)-id(other)
  
  def __hash__(self, *args, **kwargs):
    return hash(self.port_no) ^ hash(self.hw_addr) ^ \
           hash(self.name) ^ hash(self.config) ^ \
           hash(self.state) ^ hash(self.curr) ^ \
           hash(self.advertised) ^ hash(self.supported) + \
           hash(self.peer) ^ hash(self.curr_speed) + \
           hash(self.max_speed)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'hw_addr: ' + str(EthAddr(self.hw_addr)) + '\n'
    outstr += prefix + 'name: ' + str(self.name) + '\n'
    outstr += prefix + 'config: ' + str(self.config) + '\n'
    outstr += prefix + 'state: ' + str(self.state) + '\n'
    outstr += prefix + 'curr: ' + str(self.curr) + '\n'
    outstr += prefix + 'advertised: ' + str(self.advertised) + '\n'
    outstr += prefix + 'supported: ' + str(self.supported) + '\n'
    outstr += prefix + 'peer: ' + str(self.peer) + '\n'
    outstr += prefix + 'curr_speed: ' + str(self.curr_speed) + '\n'
    outstr += prefix + 'max_speed: ' + str(self.max_speed) + '\n'
    return outstr

  def __repr__(self):
    return self.show()


##2.2 Queue Structures
class ofp_packet_queue (ofp_base):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    self.queue_id = 0
    self.properties = []

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!LH", self.queue_id, len(self))
    packed += _PAD2 # Pad
    for i in self.properties:
      packed += i.pack()
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.queue_id, length) = struct.unpack_from("!LH", binaryString, 0)
    return binaryString[8:]

  def __len__ (self):
    l = 8
    for i in self.properties:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.queue_id != other.queue_id: return False
    if len(self) != len(other): return False
    if self.properties != other.properties: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'properties: \n'
    for obj in self.properties:
      outstr += obj.show(prefix + '  ')
    return outstr


class ofp_queue_prop_header (ofp_base):
  def __init__ (self, **kw):
    self.property = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HH", self.property, len(self))
    packed += _PAD4 # Pad
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.property, length) = struct.unpack_from("!HH", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.property != other.property: return False
    if len(self) != len(other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'property: ' + str(self.property) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    return outstr

class ofp_queue_prop_min_rate (ofp_base):
  def __init__ (self, **kw):
    self.prop_header = ofp_queue_prop_header()
    self.rate = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += self.prop_header.pack()
    packed += struct.pack("!H", self.rate)
    packed += _PAD6
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 16):
      return binaryString
    self.prop_header.unpack(binaryString[0:])
    (self.rate,) = struct.unpack_from("!H", binaryString, 8)
    return binaryString[16:]

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.prop_header != other.prop_header: return False
    if self.rate != other.rate: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'prop_header: \n'
    self.prop_header.show(prefix + '  ')
    outstr += prefix + 'rate: ' + str(self.rate) + '\n'
    return outstr


##2.3 Flow Match Structures
# updating for openflow 1.1
# adds an ofp_match_type struct with one member of OFPMT_STANDARD
#  - above in constants
class ofp_match (ofp_base):
  adjust_wildcards = True # Set to true to "fix" outgoing wildcards

  @classmethod
  def from_packet (cls, packet, in_port = None):
    """
    Constructs an exact match for the given packet

    @param in_port The switch port the packet arrived on if you want
                   the resulting match to have its in_port set.
                   If "packet" is a packet_in, this is ignored.
    @param packet  A pox.packet.ethernet instance or a packet_in
    """
    if isinstance(packet, ofp_packet_in):
      in_port = packet.in_port
      packet = ethernet(packet.data)
    assert assert_type("packet", packet, ethernet, none_ok=False)

    match = cls()

    if in_port is not None:
      match.in_port = in_port

    match.dl_src = packet.src
    match.dl_dst = packet.dst
    match.dl_type = packet.type
    p = packet.next
    if isinstance(p, vlan):
      match.dl_type = p.eth_type
      match.dl_vlan = p.id
      match.dl_vlan_pcp = p.pcp
      p = p.next
    else:
      match.dl_vlan = OFP_VLAN_NONE
      match.dl_vlan_pcp = 0

    if isinstance(p, ipv4):
      match.nw_src = p.srcip
      match.nw_dst = p.dstip
      match.nw_proto = p.protocol
      match.nw_tos = p.tos
      p = p.next

      if isinstance(p, udp) or isinstance(p, tcp):
        match.tp_src = p.srcport
        match.tp_dst = p.dstport
      elif isinstance(p, icmp):
        match.tp_src = p.type
        match.tp_dst = p.code
    elif isinstance(p, arp):
      if p.opcode <= 255:
        match.nw_proto = p.opcode
        match.nw_src = p.protosrc
        match.nw_dst = p.protodst

    return match

  def optimize (self):
    """
    Reduce the number of wildcards used.
    """
    #TODO: Fix for optional cases (i.e. ARP)
    if self.dl_vlan == OFP_VLAN_NONE:
      self.dl_vlan_pcp = 0

    #TODO: What do we do when something is "behind" a wildcard?
    #   e.g., does nw_src count if dl_type is wild or only if it's 0x0800?
    if self.dl_type is not None:
      if self.dl_type != 0x0800:
        # Not IP
        if self.dl_type != 0x0806:
          # Not IP or ARP
          self.nw_src = IPAddr(0)
          self.nw_dst = IPAddr(0)
          eelf.nw_proto = 0
        self.nw_tos = 0
        self.tp_src = 0
        self.tp_dst = 0
      else:
        # It's IP
        if (self.nw_proto != 6 and self.nw_proto != 17
            and self.nw_proto != 1):
          # Not TCP, UDP, or ICMP
          self.tp_src = 0
          self.tp_dst = 0
    self.wildcards = self._normalize_wildcards(self.wildcards)
    return self # for chaining

  def clone (self):
    n = ofp_match()
    for k,v in ofp_match_data.iteritems():
      setattr(n, '_' + k, getattr(self, '_' + k))
    n.wildcards = self.wildcards
    return n

  def __init__ (self, **kw):
    for k,v in ofp_match_data.iteritems():
      setattr(self, '_' + k, v[0])

    self.wildcards = self._normalize_wildcards(OFPFW_ALL)

    # This is basically initHelper(), but tweaked slightly since this
    # class does some magic of its own.
    for k,v in kw.iteritems():
      if not hasattr(self, '_'+k):
        raise TypeError(self.__class__.__name__ + " constructor got "
          + "unexpected keyword argument '" + k + "'")
      setattr(self, k, v)

  # these need to be updated for masks
  def get_nw_dst (self):
    if (self.wildcards & OFPFW_NW_DST_ALL) == OFPFW_NW_DST_ALL:
      return (None, 0)

    w = (self.wildcards & OFPFW_NW_DST_MASK) >> OFPFW_NW_DST_SHIFT
    return (self._nw_dst,32-w if w <= 32 else 0)

  def get_nw_src (self):
    if (self.wildcards & OFPFW_NW_SRC_ALL) == OFPFW_NW_SRC_ALL:
      return (None, 0)

    w = (self.wildcards & OFPFW_NW_SRC_MASK) >> OFPFW_NW_SRC_SHIFT
    return (self._nw_src,32-w if w <= 32 else 0)

  def set_nw_dst (self, *args, **kw):
    a = self._make_addr(*args, **kw)
    if a == None:
      self._nw_src = ofp_match_data['nw_dst'][0]
      self.wildcards &= ~OFPFW_NW_DST_MASK
      self.wildcards |= ofp_match_data['nw_dst'][1]
      return
    self._nw_dst = a[0]
    self.wildcards &= ~OFPFW_NW_DST_MASK
    self.wildcards |= ((32-a[1]) << OFPFW_NW_DST_SHIFT)

  def set_nw_src (self, *args, **kw):
    a = self._make_addr(*args, **kw)
    if a == None:
      self._nw_src = ofp_match_data['nw_src'][0]
      self.wildcards &= ~OFPFW_NW_SRC_MASK
      self.wildcards |= ofp_match_data['nw_src'][1]
      return
    self._nw_src = a[0]
    self.wildcards &= ~OFPFW_NW_SRC_MASK
    self.wildcards |= ((32-a[1]) << OFPFW_NW_SRC_SHIFT)

  def _make_addr (self, ipOrIPAndBits, bits=None):
    if ipOrIPAndBits == None: return None
    b = None
    if type(ipOrIPAndBits) is tuple:
      ip = ipOrIPAndBits[0]
      b = int(ipOrIPAndBits[1])

    if (type(ipOrIPAndBits) is str) and (len(ipOrIPAndBits) != 4):
      if ipOrIPAndBits.find('/') != -1:
        #s = ipOrIPAndBits.split('/')
        s = parse_cidr(ipOrIPAndBits, infer=False)
        ip = s[0]
        b = int(s[1]) if b is None else b
      else:
        ip = ipOrIPAndBits
        b = 32 if b is None else b
    else:
      ip = ipOrIPAndBits
      b = 32 if b is None else b

    if type(ip) is str:
      ip = IPAddr(ip)

    if bits != None: b = bits
    if b > 32: b = 32
    elif b < 0: b = 0

    return (ip, b)

  def __setattr__ (self, name, value):
    if name not in ofp_match_data:
      self.__dict__[name] = value
      return

    # this needs updating for _mask fields
    if name == 'nw_dst' or name == 'nw_src':
      # Special handling
      getattr(self, 'set_' + name)(value)
      return value

    if value is None:
      setattr(self, '_' + name, ofp_match_data[name][0])
      self.wildcards |= ofp_match_data[name][1]
    else:
      setattr(self, '_' + name, value)
      self.wildcards = self.wildcards & ~ofp_match_data[name][1]

    return value

  def __getattr__ (self, name):
    if name in ofp_match_data:
      if ( (self.wildcards & ofp_match_data[name][1])
           == ofp_match_data[name][1] ):
        # It's wildcarded -- always return None
        return None
      if name == 'nw_dst' or name == 'nw_src':
        # Special handling
        return getattr(self, 'get_' + name)()[0]
      return self.__dict__['_' + name]
    raise AttributeError("attribute not found: "+name)

  def _validate (self):
    # TODO
    return None

  def pack (self, flow_mod=False):
    # OF 1.0 looks like:
    # 32-bit wildcards
    # 16-bit in_port
    # 6x8bit source_eth
    # 6x8bit dest_eth
    # 16-bit VLAN ID
    # 8-bit VLAN PCP (priority)
    # 8-bit padding
    # 16-bit dl_type
    # 8-bit IP DSCP
    # 8-bit IP proto / ARP lower 8 bits of opcode
    # 2x8-bit align
    # 32-bit source IP
    # 32-bit dest IP
    # 16-bit source port
    # 16-bit dest port
    # 40 bytes total
    
    # OF 1.1 looks like:
    # 16-bit type
    # 16-bit length
    # 32-bit in_port
    # 32-bit wildcards
    # 6x8bit source_eth
    # 6x8bit source_eth_mask (dl_src_mask)
    # 6x8bit dest_eth
    # 6x8bit dest_eth_mask (dl_dst_mask)
    # 16-bit vlan ID
    # 8-bit VLAN pcp (priority)
    # 8-bit padding
    # 16-bit dl_type
    # 8-bit IP DSCP
    # 8-bit IP proto
    # 32-bit source IP
    # 32-bit source IP mask (nw_src_mask)
    # 32-bit dest IP
    # 32-bit dest IP mask (nw_dst_mask)
    # 16-bit source port
    # 16-bit dest-port
    # 32-bit MLS label (mpls_label)
    # 8-bit MPLS TC (mpls_tc)
    # 3x8bit padding
    # 64-bit metadata (metadata)
    # 64-bit metadata_mask (metadata_mask)
    
    assert self._assert()

    packed = ""
    # start with type and length
    packed += struct.pack("!HH", OFPMT_STANDARD, 88)
    if self.adjust_wildcards and flow_mod:
      wc = self._wire_wildcards(self.wildcards)
    else:
      wc = self.wildcards
    # port length now 32-bits
    packed += struct.pack("!LL", self.in_port or 0, wc)
    if self.dl_src == None:
      packed += EMPTY_ETH.toRaw()
    elif type(self.dl_src) is bytes:
      packed += self.dl_src
    else:
      packed += self.dl_src.toRaw()
    if self.dl_src_mask == None:
      packed += EMPTY_ETH.toRaw()
    elif type(self.dl_src_mask) is bytes:
      packed += self.dl_src_mask
    else:
      packed += self.dl_src_mask.toRaw()
    if self.dl_dst == None:
      packed += EMPTY_ETH.toRaw()
    elif type(self.dl_dst) is bytes:
      packed += self.dl_dst
    else:
      packed += self.dl_dst.toRaw()
    if self.dl_dst_mask == None:
      packed += EMPTY_ETH.toRaw()
    elif type(self.dl_dst_mask) is bytes:
      packed += self.dl_dst_mask
    else:
      packed += self.dl_dst_mask.toRaw()

    def check_ip(val):
      return (val or 0) if self.dl_type == 0x0800 else 0
    def check_ip_or_arp(val):
      return (val or 0) if self.dl_type == 0x0800 \
                           or self.dl_type == 0x0806 else 0
    def check_tp(val):
      return (val or 0) if self.dl_type == 0x0800 \
                           and self.nw_proto in (1,6,17) else 0

    packed += struct.pack("!HB", self.dl_vlan or 0, self.dl_vlan_pcp or 0)
    packed += _PAD # Hardcode padding
    packed += struct.pack("!HBB", self.dl_type or 0,
        check_ip(self.nw_tos), check_ip_or_arp(self.nw_proto))
    
    def fix (addr):
      if addr is None: return 0
      if type(addr) is int: return addr & 0xffFFffFF
      if type(addr) is long: return addr & 0xffFFffFF
      return addr.toUnsigned()

    packed += struct.pack("!LLLLHH", check_ip_or_arp(fix(self.nw_src)),
        check_ip_or_arp(fix(self.nw_src_mask)),
        check_ip_or_arp(fix(self.nw_dst)),
        check_ip_or_arp(fix(self.nw_dst_mask)),
        check_tp(self.tp_src), check_tp(self.tp_dst))
    
    # now MPLS stuff
    
    packed += struct.pack("!LB", self.mpls_label, self.mpls_tc)
    packed += _PAD3
    packed += struct.pack("!QQ", self.metadata, self.metadata_mask)
    
    # should we assert that the size is correct?
    

    return packed

  def _normalize_wildcards (self, wildcards):
    # this isn't necessary in OpenFlow 1.1 - nw_src and nw_dst wildcards are a bitmask
    """
    nw_src and nw_dst values greater than 32 mean the same thing as 32.
    We normalize them here just to be clean and so that comparisons act
    as you'd want them to.
    """
    if ((wildcards & OFPFW_NW_SRC_MASK) >> OFPFW_NW_SRC_SHIFT) > 32:
      wildcards &= ~OFPFW_NW_SRC_MASK
      wildcards |= (32 << OFPFW_NW_SRC_SHIFT)
    if ((wildcards & OFPFW_NW_DST_MASK) >> OFPFW_NW_DST_SHIFT) > 32:
      wildcards &= ~OFPFW_NW_DST_MASK
      wildcards |= (32 << OFPFW_NW_DST_SHIFT)
    return wildcards

  def _wire_wildcards(self, wildcards):
    """
    Normalize the wildcard bits to the openflow wire representation.
    Note this atrocity from the OF1.1 spec:
    Protocol-specific fields within ofp_match will be ignored within
    a single table when the corresponding protocol is not specified in the
    match.  The IP header and transport header fields
    will be ignored unless the Ethertype is specified as either IPv4 or
    ARP. The tp_src and tp_dst fields will be ignored unless the network
    protocol specified is as TCP, UDP or SCTP. Fields that are ignored
    don't need to be wildcarded and should be set to 0.
    """
    # this will need recoding nw_src_mask and nw_src_dst don't make
    # sense here
    if self.dl_type == 0x0800:
        # IP
        if  self.nw_proto not in (1,6,17):
          # not TCP/UDP/ICMP -> Clear TP wildcards for the wire
          return wildcards & ~(OFPFW_TP_SRC | OFPFW_TP_DST)
        else:
          return wildcards
    elif self.dl_type == 0x0806:
        # ARP: clear NW_TOS / TP wildcards for the wire
        return wildcards & ~( OFPFW_NW_TOS | OFPFW_TP_SRC | OFPFW_TP_DST)
    else:
        # not even IP. Clear NW/TP wildcards for the wire
        return wildcards & ~( OFPFW_NW_TOS | OFPFW_NW_PROTO
            | OFPFW_NW_SRC_MASK | OFPFW_NW_DST_MASK
            | OFPFW_TP_SRC | OFPFW_TP_DST)


  def _unwire_wildcards(self, wildcards):
    """
    Normalize the wildcard bits from the openflow wire representation.
    Note this atrocity from the OF1.1 spec:
    Protocol-specific fields within ofp_match will be ignored within
    a single table when the corresponding protocol is not specified in the
    match.  The IP header and transport header fields
    will be ignored unless the Ethertype is specified as either IPv4 or
    ARP. The tp_src and tp_dst fields will be ignored unless the network
    protocol specified is as TCP, UDP or SCTP. Fields that are ignored
    don't need to be wildcarded and should be set to 0.
    """
    # same as above - src_mask and dst_mask are meaningless here
    if self._dl_type == 0x0800:
        # IP
        if  self._nw_proto not in (1,6,17):
          # not TCP/UDP/ICMP -> Set TP wildcards for the object
          return wildcards | (OFPFW_TP_SRC | OFPFW_TP_DST)
        else:
          return wildcards
    elif self._dl_type == 0x0806:
        # ARP: Set NW_TOS / TP wildcards for the object
        return wildcards | ( OFPFW_NW_TOS | OFPFW_TP_SRC | OFPFW_TP_DST)
    else:
        # not even IP. Set NW/TP wildcards for the object
        return wildcards | ( OFPFW_NW_TOS | OFPFW_NW_PROTO
                             | OFPFW_NW_SRC_MASK | OFPFW_NW_DST_MASK
                             | OFPFW_TP_SRC | OFPFW_TP_DST)


  @property
  def is_wildcarded (self):
    return self.wildcards & OFPFW_ALL != 0

  @property
  def is_exact (self):
    return not self.is_wildcarded

  def unpack (self, binaryString, flow_mod=False):
    # OF 1.0 looks like:
    # 32-bit wildcards
    # 16-bit in_port
    # 6x8bit source_eth
    # 6x8bit dest_eth
    # 16-bit VLAN ID
    # 8-bit VLAN PCP (priority)
    # 8-bit padding
    # 16-bit dl_type
    # 8-bit IP DSCP
    # 8-bit IP proto / ARP lower 8 bits of opcode
    # 2x8-bit align
    # 32-bit source IP
    # 32-bit dest IP
    # 16-bit source port
    # 16-bit dest port
    # 40 bytes total
    
    # OF 1.1 looks like:
    # 16-bit type
    # 16-bit length
    # 32-bit in_port
    # 32-bit wildcards
    # 6x8bit source_eth
    # 6x8bit source_eth_mask (dl_src_mask)
    # 6x8bit dest_eth
    # 6x8bit dest_eth_mask (dl_dst_mask)
    # 16-bit vlan ID
    # 8-bit VLAN pcp (priority)
    # 8-bit padding
    # 16-bit dl_type
    # 8-bit IP DSCP
    # 8-bit IP proto
    # 32-bit source IP
    # 32-bit source IP mask (nw_src_mask)
    # 32-bit dest IP
    # 32-bit dest IP mask (nw_dst_mask)
    # 16-bit source port
    # 16-bit dest-port
    # 32-bit MLS label (mpls_label)
    # 8-bit MPLS TC (mpls_tc)
    # 3x8bit padding
    # 64-bit metadata (metadata)
    # 64-bit metadata_mask (metadata_mask)
    
    # openflow 1.1 has a type and length field - we need to get
    # these first and then compare to expected lengths
    (match_type, match_length) = struct.unpack_from("!HH", binarystring, 0)
    # this comparision needs to be changed
    if (len(binaryString) < self.__len__()):
      return binaryString
    # in_port now 32-bits, swapped around
    (self._in_port, wildcards) = struct.unpack_from("!LL",binaryString, 4)
    # masks as well as addresses (follow where the _mask stuff goes)
    self._dl_src = EthAddr(struct.unpack_from("!BBBBBB",binaryString, 12))
    self._dl_src_mask = \
        EthAddr(struct.unpack_from("!BBBBBB", binaryString, 18))
    self._dl_dst = EthAddr(struct.unpack_from("!BBBBBB",binaryString, 24))
    self._dl_dst_mask = \
        EthAddr(struct.unpack_from("!BBBBBB", binaryString, 30))
    (self._dl_vlan, self._dl_vlan_pcp) = \
        struct.unpack_from("!HB", binaryString, 36)
    (self._dl_type, self._nw_tos, self._nw_proto) = \
        struct.unpack_from("!HBB", binaryString, 40)
    # masks as well as addresses (follow where the _mask stuff goes)
    (self._nw_src, self._nw_src_mask, self._nw_dst, self._nw_dst_mask,
        self._tp_src, self._tp_dst) = \
        struct.unpack_from("!LLLLHH", binaryString, 44)
    self._nw_src = IPAddr(self._nw_src)
    self._nw_src_mask = IPAddr(self._nw_src_mask)
    self._nw_dst = IPAddr(self._nw_dst)
    self._nw_dst_mask = IPAddr(self._nw_dst_mask)
    # counted up to 64 bytes now, time for MPLS then 3 pad bytes
    (self._mpls_label, self._mpls_tc) = \
        struct.unpack_from("!LB", binaryString, 64)
    (self._metadata, self._metadata_mask) = \
        struct.unpack_from("!QQ", binaryString, 72)

    # Only unwire wildcards for flow_mod
    self.wildcards = self._normalize_wildcards(
        self._unwire_wildcards(wildcards) if flow_mod else wildcards)

    return binaryString[len(self):]

  # updated for openflow 1.1
  @staticmethod
  def __len__ ():
    return 88

  def hash_code (self):
    '''
    ofp_match is not properly hashable since it is mutable, but it can
    still be useful to easily generate a hash code.
    '''

    h = self.wildcards
    for f in ofp_match_data:
      v = getattr(self, f)
      if type(v) is int:
        h ^= v
      elif type(v) is long:
        h ^= v

    return int(h & 0x7fFFffFF)

  # needs to be updated for openflow 1.1 matches
  def matches_with_wildcards (self, other, consider_other_wildcards=True):
    """
    Test whether /this/ match completely encompasses the other match.
    Important for non-strict modify flow_mods etc.
    """
    assert assert_type("other", other, ofp_match, none_ok=False)
    # short cut for equal matches
    if(self == other): return True
    # only candidate if all wildcard bits in the *other* match are also
    # set in this match (i.e., a submatch)

    # first compare the bitmask part
    if(consider_other_wildcards):
      self_bits  = self.wildcards&~(OFPFW_NW_SRC_MASK|OFPFW_NW_DST_MASK)
      other_bits = other.wildcards&~(OFPFW_NW_SRC_MASK|OFPFW_NW_DST_MASK)
      if( self_bits | other_bits != self_bits): return False

    def match_fail(mine, others):
      return mine != None and mine != others

    if match_fail(self.in_port, other.in_port): return False
    if match_fail(self.dl_vlan, other.dl_vlan): return False
    if match_fail(self.dl_src, other.dl_src): return False
    if match_fail(self.dl_dst, other.dl_dst): return False
    if match_fail(self.dl_type, other.dl_type): return False
    if match_fail(self.nw_proto, other.nw_proto): return False
    if match_fail(self.tp_src, other.tp_src): return False
    if match_fail(self.tp_dst, other.tp_dst): return False
    if match_fail(self.dl_vlan_pcp, other.dl_vlan_pcp): return False
    if match_fail(self.nw_tos, other.nw_tos): return False

    self_nw_src = self.get_nw_src()
    if(self_nw_src[0] != None):
      other_nw_src = other.get_nw_src()
      if self_nw_src[1] > other_nw_src[1]: return False
      if not IPAddr(other_nw_src[0]).inNetwork(
            (self_nw_src[0], self_nw_src[1])): return False

    self_nw_dst = self.get_nw_dst()
    if(self_nw_dst[0] != None):
      other_nw_dst = other.get_nw_dst()
      if self_nw_dst[1] > other_nw_dst[1]: return False
      if not IPAddr(other_nw_dst[0]).inNetwork(
            (self_nw_dst[0], self_nw_dst[1])): return False

    return True

  # needs to be updated for openflow 1.1 matches
  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.wildcards != other.wildcards: return False
    if self.in_port != other.in_port: return False
    if self.dl_src != other.dl_src: return False
    if self.dl_dst != other.dl_dst: return False
    if self.dl_vlan != other.dl_vlan: return False
    if self.dl_vlan_pcp != other.dl_vlan_pcp: return False
    if self.dl_type != other.dl_type: return False
    if self.nw_tos != other.nw_tos: return False
    if self.nw_proto != other.nw_proto: return False
    if self.nw_src != other.nw_src: return False
    if self.nw_dst != other.nw_dst: return False
    if self.tp_src != other.tp_src: return False
    if self.tp_dst != other.tp_dst: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def __str__ (self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def show (self, prefix=''):
    def binstr (n):
      s = ''
      while True:
        s = ('1' if n & 1 else '0') + s
        n >>= 1
        if n == 0: break
      return s
    def safehex(n):
      if n == None:
        return "(None)"
      else:
        return hex(n)

    def show_wildcards(w):
      parts = [ k.lower()[len("OFPFW_"):]
                for (k,v) in ofp_flow_wildcards_rev_map.iteritems()
                if v & w == v ]
      nw_src_bits = (w & OFPFW_NW_SRC_MASK) >> OFPFW_NW_SRC_SHIFT
      if nw_src_bits > 0:
        parts.append("nw_src(/%d)" % (32 - nw_src_bits))

      nw_dst_bits = (w & OFPFW_NW_DST_MASK) >> OFPFW_NW_DST_SHIFT
      if nw_dst_bits > 0:
        parts.append("nw_dst(/%d)" % (32 - nw_dst_bits))

      return "|".join(parts)

    outstr = ''
    outstr += prefix + 'wildcards: '
    outstr += show_wildcards(self.wildcards)
    outstr += ' (%s = %x)\n' % (binstr(self.wildcards), self.wildcards)
    def append (f, formatter=str):
      v = self.__getattr__(f)
      if v is None: return ''
      return prefix + f + ": " + formatter(v) + "\n"
    outstr += append('in_port')
    outstr += append('dl_src')
    outstr += append('dl_dst')
    outstr += append('dl_vlan')
    outstr += append('dl_vlan_pcp')
    outstr += append('dl_type', safehex)
    outstr += append('nw_tos')
    outstr += append('nw_proto')
    outstr += append('nw_src')
    outstr += append('nw_dst')
    outstr += append('tp_src')
    outstr += append('tp_dst')
    return outstr


class ofp_action_generic (ofp_action_base):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    self.type = None # Purposely bad
    self.data = _PAD4

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HH", self.type, len(self))
    packed += _PAD4 # Pad
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length) = struct.unpack_from("!HH", binaryString, 0)
    if len(binaryString) < length: return binaryString
    self.data = binaryString[4:4+length]
    return binaryString[length:]

  def __len__ (self):
    return 4 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    return outstr


@openflow_action('OFPAT_OUTPUT', 0)
class ofp_action_output (ofp_action_base):
  def __init__ (self, **kw):
    self.port = None # Purposely bad -- require specification
    self.max_len = 0xffFF

    initHelper(self, kw)

  def pack (self):
    if self.port != OFPP_CONTROLLER:
      self.max_len = 0

    assert self._assert()

    packed = ""
    packed += struct.pack("!HHHH", self.type, len(self), self.port, self.max_len)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.port, self.max_len) = struct.unpack_from("!HHHH", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.port != other.port: return False
    if self.max_len != other.max_len: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    outstr += prefix + 'max_len: ' + str(self.max_len) + '\n'
    return outstr


@openflow_action('OFPAT_ENQUEUE', 11)
class ofp_action_enqueue (ofp_action_base):
  def __init__ (self, **kw):
    self.port = None # Require user to set
    self.queue_id = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHH", self.type, len(self), self.port)
    packed += _PAD6 # Pad
    packed += struct.pack("!L", self.queue_id)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 16):
      return binaryString
    (self.type, length, self.port) = struct.unpack_from("!HHH", binaryString, 0)
    (self.queue_id,) = struct.unpack_from("!L", binaryString, 12)
    return binaryString[16:]

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.port != other.port: return False
    if self.queue_id != other.queue_id: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    return outstr


@openflow_action('OFPAT_STRIP_VLAN', 3)
class ofp_action_strip_vlan (ofp_action_base):
  def __init__ (self):
    pass

  def pack (self):
    packed = struct.pack("!HHi", self.type, len(self), 0)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length) = struct.unpack_from("!HH", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    return outstr


@openflow_action('OFPAT_SET_VLAN_VID', 1)
class ofp_action_vlan_vid (ofp_action_base):
  def __init__ (self, **kw):
    self.vlan_vid = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHH", self.type, len(self), self.vlan_vid)
    packed += _PAD2 # Pad
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.vlan_vid) = struct.unpack_from("!HHH", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vlan_vid != other.vlan_vid: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vlan_vid: ' + str(self.vlan_vid) + '\n'
    return outstr


@openflow_action('OFPAT_SET_VLAN_PCP', 2)
class ofp_action_vlan_pcp (ofp_action_base):
  def __init__ (self, **kw):
    self.vlan_pcp = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHB", self.type, len(self), self.vlan_pcp)
    packed += _PAD3 # Pad
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.vlan_pcp) = struct.unpack_from("!HHB", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vlan_pcp != other.vlan_pcp: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vlan_pcp: ' + str(self.vlan_pcp) + '\n'
    return outstr


@openflow_action('OFPAT_SET_DL_DST', 5)
@openflow_action('OFPAT_SET_DL_SRC', 4)
class ofp_action_dl_addr (ofp_action_base):
  @classmethod
  def set_dst (cls, dl_addr = None):
    return cls(OFPAT_SET_DL_DST, dl_addr)
  @classmethod
  def set_src (cls, dl_addr = None):
    return cls(OFPAT_SET_DL_SRC, dl_addr)

  def __init__ (self, type = None, dl_addr = None):
    """
    'type' should be OFPAT_SET_DL_SRC or OFPAT_SET_DL_DST.
    """
    self.type = type
    self.dl_addr = EMPTY_ETH

    if dl_addr is not None:
      self.dl_addr = EthAddr(dl_addr)

  def _validate (self):
    if (not isinstance(self.dl_addr, EthAddr)
        and not isinstance(self.dl_addr, bytes)):
      return "dl_addr is not string or EthAddr"
    if isinstance(self.dl_addr, bytes) and len(self.dl_addr) != 6:
      return "dl_addr is not of size 6"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HH", self.type, len(self))
    if isinstance(self.dl_addr, EthAddr):
      packed += self.dl_addr.toRaw()
    else:
      packed += self.dl_addr
    packed += _PAD6
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 16):
      return binaryString
    (self.type, length) = struct.unpack_from("!HH", binaryString, 0)
    self.dl_addr = EthAddr(struct.unpack_from("!BBBBBB", binaryString, 4))
    return binaryString[16:]

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.dl_addr != other.dl_addr: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'dl_addr: ' + str(self.dl_addr) + '\n'
    return outstr


@openflow_action('OFPAT_SET_NW_DST', 7)
@openflow_action('OFPAT_SET_NW_SRC', 6)
class ofp_action_nw_addr (ofp_action_base):
  @classmethod
  def set_dst (cls, nw_addr = None):
    return cls(OFPAT_SET_NW_DST, nw_addr)
  @classmethod
  def set_src (cls, nw_addr = None):
    return cls(OFPAT_SET_NW_SRC, nw_addr)

  def __init__ (self, type = None, nw_addr = None):
    """
    'type' should be OFPAT_SET_NW_SRC or OFPAT_SET_NW_DST
    """
    self.type = type

    if nw_addr is not None:
      self.nw_addr = IPAddr(nw_addr)
    else:
      self.nw_addr = IPAddr(0)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHl", self.type, len(self), self.nw_addr.toSigned())
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.nw_addr) = struct.unpack_from("!HHL", binaryString, 0)
    self.nw_addr = IPAddr(self.nw_addr, networkOrder=False)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.nw_addr != other.nw_addr: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'nw_addr: ' + str(self.nw_addr) + '\n'
    return outstr


@openflow_action('OFPAT_SET_NW_TOS', 8)
class ofp_action_nw_tos (ofp_action_base):
  def __init__ (self, nw_tos = 0):
    self.nw_tos = nw_tos

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHB", self.type, len(self), self.nw_tos)
    packed += _PAD3
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.nw_tos) = struct.unpack_from("!HHB", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.nw_tos != other.nw_tos: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'nw_tos: ' + str(self.nw_tos) + '\n'
    return outstr


@openflow_action('OFPAT_SET_TP_DST', 10)
@openflow_action('OFPAT_SET_TP_SRC', 9)
class ofp_action_tp_port (ofp_action_base):
  @classmethod
  def set_dst (cls, tp_port = None):
    return cls(OFPAT_SET_TP_DST, tp_port)
  @classmethod
  def set_src (cls, tp_port = None):
    return cls(OFPAT_SET_TP_SRC, tp_port)

  def __init__ (self, type=None, tp_port = 0):
    """
    'type' is OFPAT_SET_TP_SRC/DST
    """
    self.type = type
    self.tp_port = tp_port

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHH", self.type, len(self), self.tp_port)
    packed += _PAD2
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.tp_port) = struct.unpack_from("!HHH", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.tp_port != other.tp_port: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'tp_port: ' + str(self.tp_port) + '\n'
    return outstr


@openflow_action('OFPAT_VENDOR', 65535)
class ofp_action_vendor_header (ofp_action_base):
  def __init__ (self, **kw):
    self.vendor = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HHL", self.type, len(self), self.vendor)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.type, length, self.vendor) = struct.unpack_from("!HHL", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vendor != other.vendor: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vendor: ' + str(self.vendor) + '\n'
    return outstr


#3. Controller-to-Switch Messages

##3.1 Handshake
# was ofp_switch_features
#TODO: Set name back?
@openflow_s_message("OFPT_FEATURES_REPLY", 6,
    reply_to="ofp_features_request")
class ofp_features_reply (ofp_header):
  _MIN_LENGTH = 32
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.datapath_id = 0
    self.n_buffers = 0
    self.n_tables = 0
    self.capabilities = 0
    self.actions = 0
    self.ports = []
    
    initHelper(self, kw)
  
  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!QLB", self.datapath_id, self.n_buffers, self.n_tables)
    packed += _PAD3
    packed += struct.pack("!LL", self.capabilities, self.actions)
    for i in self.ports:
      packed += i.pack()
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 32):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.datapath_id, self.n_buffers, self.n_tables) = struct.unpack_from("!QLB", binaryString, 8)
    (self.capabilities, self.actions) = struct.unpack_from("!LL", binaryString, 24)
    portCount = (self._length - 32) / len(ofp_phy_port)
    self.ports = []
    for i in xrange(0, portCount):
      p = ofp_phy_port()
      p.unpack(binaryString[32+i*len(ofp_phy_port):])
      self.ports.append(p)
    return binaryString[self._length:]

  def __len__ (self):
    l = 32
    for _ in self.ports:
      l += len(ofp_phy_port)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.datapath_id != other.datapath_id: return False
    if self.n_buffers != other.n_buffers: return False
    if self.n_tables != other.n_tables: return False
    if self.capabilities != other.capabilities: return False
    if self.actions != other.actions: return False
    if self.ports != other.ports: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'datapath_id: ' + str(self.datapath_id) + '\n'
    outstr += prefix + 'n_buffers: ' + str(self.n_buffers) + '\n'
    outstr += prefix + 'n_tables: ' + str(self.n_tables) + '\n'
    outstr += prefix + 'capabilities: ' + str(self.capabilities) + '\n'
    outstr += prefix + 'actions: ' + str(self.actions) + '\n'
    outstr += prefix + 'ports: \n'
    for obj in self.ports:
      outstr += obj.show(prefix + '  ')
    return outstr

ofp_switch_features = ofp_features_reply


##3.2 Switch Configuration
@openflow_c_message("OFPT_SET_CONFIG", 9)
class ofp_switch_config (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.flags = 0
    self.miss_send_len = OFP_DEFAULT_MISS_SEND_LEN

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.flags, self.miss_send_len)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.flags, self.miss_send_len) = struct.unpack_from("!HH", binaryString, 8)
    return binaryString[12:]

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.flags != other.flags: return False
    if self.miss_send_len != other.miss_send_len: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'miss_send_len: ' + str(self.miss_send_len) + '\n'
    return outstr


##3.3 Modify State Messages
@openflow_c_message("OFPT_FLOW_MOD", 14)
class ofp_flow_mod (ofp_header):
  _MIN_LENGTH = 72
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    if 'match' in kw:
      self.match = None
    else:
      self.match = ofp_match()
    self.cookie = 0
    self.command = OFPFC_ADD
    self.idle_timeout = 0
    self.hard_timeout = 0
    self.priority = OFP_DEFAULT_PRIORITY
    self._buffer_id = NO_BUFFER
    self.out_port = OFPP_NONE
    self.flags = 0
    self.actions = []
    self.data = None # Not in the spec!  Special magic!  Can be packet_in.

    # ofp_flow_mod/ofp_packet_out do some special handling of 'actions'...

    # Allow "action" as a synonym for "actions"
    if 'action' in kw and 'actions' not in kw:
      kw['actions'] = kw['action']
      del kw['action']

    initHelper(self, kw)

    # Allow use of actions=<a single action> for kw args.
    if not hasattr(self.actions, '__getitem__'):
      self.actions = [self.actions]

  @property
  def buffer_id (self):
    if self._buffer_id == NO_BUFFER: return None
    return self._buffer_id
  @buffer_id.setter
  def buffer_id (self, val):
    if val is None: val = NO_BUFFER
    self._buffer_id = val

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    """
    Packs this object into its wire format.
    May normalize fields.
    NOTE: If "data" has been specified, this method may actually return
          *more than just a single ofp_flow_mod* in packed form.
          Specifically, it may also have a barrier and an ofp_packet_out.
    """
    po = None
    if self.data:
      #TODO: It'd be nice to log and then ignore if not data_is_complete.
      #      Unfortunately, we currently have no logging in here, so we
      #      assert instead which is a either too drastic or too quiet.
      assert self.data.is_complete
      assert self.buffer_id is None
      self.buffer_id = self.data.buffer_id
      if self.buffer_id is None:
        po = ofp_packet_out(data=self.data)
        po.in_port = self.data.in_port
        po.actions.add(ofp_action_output(port = OFPP_TABLE))
        # Should maybe check that packet hits the new entry...
        # Or just duplicate the actions?

    assert self._assert()
    packed = ""
    packed += ofp_header.pack(self)
    packed += self.match.pack(flow_mod=True)
    packed += struct.pack("!QHHHHLHH", self.cookie, self.command, self.idle_timeout, self.hard_timeout, self.priority, self._buffer_id, self.out_port, self.flags)
    for i in self.actions:
      packed += i.pack()

    if po:
      packet += ofp_barrier_request().pack()
      packet += po.pack()
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 72):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    self.match.unpack(binaryString[8:], flow_mod=True)
    (self.cookie, self.command, self.idle_timeout, self.hard_timeout, self.priority, self._buffer_id, self.out_port, self.flags) = struct.unpack_from("!QHHHHLHH", binaryString, 8 + len(self.match))
    self.actions, offset = _unpack_actions(binaryString, self._length-(32 + len(self.match)), 32 + len(self.match))
    assert offset == self._length
    return binaryString[offset:]

  def __len__ (self):
    l = 32 + len(self.match)
    for i in self.actions:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.match != other.match: return False
    if self.cookie != other.cookie: return False
    if self.command != other.command: return False
    if self.idle_timeout != other.idle_timeout: return False
    if self.hard_timeout != other.hard_timeout: return False
    if self.priority != other.priority: return False
    if self.buffer_id != other.buffer_id: return False
    if self.out_port != other.out_port: return False
    if self.flags != other.flags: return False
    if self.actions != other.actions: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'command: ' + str(self.command) + '\n'
    outstr += prefix + 'idle_timeout: ' + str(self.idle_timeout) + '\n'
    outstr += prefix + 'hard_timeout: ' + str(self.hard_timeout) + '\n'
    outstr += prefix + 'priority: ' + str(self.priority) + '\n'
    outstr += prefix + 'buffer_id: ' + str(self.buffer_id) + '\n'
    outstr += prefix + 'out_port: ' + str(self.out_port) + '\n'
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'actions: \n'
    for obj in self.actions:
      outstr += obj.show(prefix + '  ')
    return outstr

# new in openflow 1.1 
@openflow_c_message("OFPT_GROUP_MOD", 15)
class ofp_group_mod (ofp_header):
  _MIN_LENGTH = 0 # set this to something useful
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    # extra stuff

  @property
  def buffer_id (self):
    return None
  @buffer_id.setter
  def buffer_id (self, val):
    return None

  def _validate (self):
    return None

  def pack (self):
    """
    Packs this object into its wire format.
    May normalize fields.
    NOTE: If "data" has been specified, this method may actually return
          *more than just a single ofp_flow_mod* in packed form.
          Specifically, it may also have a barrier and an ofp_packet_out.
    """
    return None

  def unpack (self, binaryString):
    return None

  def __len__ (self):
    return 0

  def __eq__ (self, other):
    return False

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    return None


@openflow_c_message("OFPT_PORT_MOD", 16)
class ofp_port_mod (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.port_no = 0
    self.hw_addr = EMPTY_ETH
    self.config = 0
    self.mask = 0
    self.advertise = 0

    initHelper(self, kw)

  def _validate (self):
    if (not isinstance(self.hw_addr, bytes)
        and not isinstance(self.hw_addr, EthAddr)):
      return "hw_addr is not bytes or EthAddr"
    if len(self.hw_addr) != 6:
      return "hw_addr is not of size 6"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!H", self.port_no)
    if isinstance(self.hw_addr, bytes):
      packed += self.hw_addr
    else:
      packed += self.hw_addr.toRaw()
    packed += struct.pack("!LLL", self.config, self.mask, self.advertise)
    packed += _PAD4
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 32):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.port_no,) = struct.unpack_from("!H", binaryString, 8)
    self.hw_addr = EthAddr(binaryString[10:16])
    (self.config, self.mask, self.advertise) = struct.unpack_from("!LLL", binaryString, 16)
    return binaryString[32:]

  @staticmethod
  def __len__ ():
    return 32

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.port_no != other.port_no: return False
    if self.hw_addr != other.hw_addr: return False
    if self.config != other.config: return False
    if self.mask != other.mask: return False
    if self.advertise != other.advertise: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'hw_addr: ' + str(EthAddr(self.hw_addr)) + '\n'
    outstr += prefix + 'config: ' + str(self.config) + '\n'
    outstr += prefix + 'mask: ' + str(self.mask) + '\n'
    outstr += prefix + 'advertise: ' + str(self.advertise) + '\n'
    return outstr


# new in openflow 1.1 
@openflow_c_message("OFPT_TABLE_MOD", 17)
class ofp_table_mod (ofp_header):
  _MIN_LENGTH = 0 # set this to something useful
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    # extra stuff

  @property
  def buffer_id (self):
    return None
  @buffer_id.setter
  def buffer_id (self, val):
    return None

  def _validate (self):
    return None

  def pack (self):
    """
    Packs this object into its wire format.
    May normalize fields.
    NOTE: If "data" has been specified, this method may actually return
          *more than just a single ofp_flow_mod* in packed form.
          Specifically, it may also have a barrier and an ofp_packet_out.
    """
    return None

  def unpack (self, binaryString):
    return None

  def __len__ (self):
    return 0

  def __eq__ (self, other):
    return False

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    return None


##3.4 Queue Configuration Messages
@openflow_c_message("OFPT_QUEUE_GET_CONFIG_REQUEST", 22)
class ofp_queue_get_config_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.port = 0
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!H", self.port)
    packed += _PAD2
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.port,) = struct.unpack_from("!H", binaryString, 8)
    return binaryString[12:]

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.port != other.port: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    return outstr


@openflow_s_message("OFPT_QUEUE_GET_CONFIG_REPLY", 23)
class ofp_queue_get_config_reply (ofp_header):
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.port = 0
    self.queues = []

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!H", self.port)
    packed += _PAD6
    for i in self.queues:
      packed += i.pack()
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 16):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.port,) = struct.unpack_from("!H", binaryString, 8)
    return binaryString[16:]

  def __len__ (self):
    l = 16
    for i in self.queues:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.port != other.port: return False
    if self.queues != other.queues: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    outstr += prefix + 'queues: \n'
    for obj in self.queues:
      outstr += obj.show(prefix + '  ')
    return outstr


@openflow_c_message("OFPT_STATS_REQUEST", 18)
class ofp_stats_request (ofp_header):
  _MIN_LENGTH = 12
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.type = None # Try to guess
    self.flags = 0
    self.body = b''
    self._body_data = (None, None)

    initHelper(self, kw)

  def pack (self):
    if self.type is None:
      if isinstance(self.body, ofp_stats_body_base):
        self.type = self.body._type
      else:
        raise RuntimeError("Can't determine body type; specify it explicitly")

    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.type, self.flags)
    packed += self.body_data
    return packed

  @property
  def body_data (self):
    if self._body_data[0] is not self.body:
      if hasattr(self.body, 'pack'):
        self._body_data = (self.body, self.body.pack())
      else:
        self._body_data = (self.body, self.body)
    return self._body_data[1]

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.type, self.flags) = struct.unpack_from("!HH", binaryString, 8)
    self.body = binaryString[12:self._length]
    return binaryString[self._length:]

  def __len__ (self):
    return 12 + len(self.body_data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.type != other.type: return False
    if self.flags != other.flags: return False
    if self.body_data != other.body_data: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


@openflow_s_message("OFPT_STATS_REPLY", 19,
    reply_to="ofp_stats_request")
class ofp_stats_reply (ofp_header):
  _MIN_LENGTH = 12
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.type = None # Guess
    self.flags = 0
    self.body = b''
    self._body_data = (None, None)

    initHelper(self, kw)

  @property
  def is_last_reply (self):
    return (self.flags & 1) == 0
  @is_last_reply.setter
  def is_last_reply (self, value):
    self.flags = self.flags & 0xfffe
    if not value:
      self.flags |= 1

  @property
  def body_data (self):
    if self._body_data[0] is not self.body:
      def _pack(b):
        return b.pack() if hasattr(b, 'pack') else b

      data = b''
      if isinstance(self.body, collections.Iterable):
        for b in self.body:
          data += _pack(b)
      else:
        data = _pack(self.body)
      self._body_data = (self.body, data)
    return self._body_data[1]

  def pack (self):
    if self.type is None:
      if isinstance(self.body, ofp_stats_body_base):
        self.type = self.body._type
      else:
        raise RuntimeError("Can't determine body type; specify it explicitly")

    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.type, self.flags)
    packed += self.body_data
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.type, self.flags) = struct.unpack_from("!HH", binaryString, 8)
    packed = binaryString[12:self._length]
    t = _stats_type_to_class_info.get(self.type)
    if t is None:
      #FIXME: Put in a generic container?
      self.body = packed
    else:
      if t.reply is None:
        #FIXME: Put in a generic container?
        self.body = packed
      else:
        if not t.reply_is_list:
          self.body = t.reply()
          self.body.unpack(packed)
        else:
          prev_len = len(packed)
          self.body = []
          while len(packed):
            part = t.reply()
            packed = part.unpack(packed)
            assert len(packed) != prev_len
            prev_len = len(packed)
            self.body.append(part)

    return binaryString[self._length:]

  def __len__ (self):
    return 12 + len(self.body)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.type != other.type: return False
    if self.flags != other.flags: return False
    if self.body != other.body: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


@openflow_stats_reply("OFPST_DESC", 0)
class ofp_desc_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.mfr_desc= ""
    self.hw_desc= ""
    self.sw_desc= ""
    self.serial_num= ""
    self.dp_desc= ""

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.mfr_desc, str):
      return "mfr_desc is not string"
    if len(self.mfr_desc) > 256:
      return "mfr_desc is not of size 256"
    if not isinstance(self.hw_desc, str):
      return "hw_desc is not string"
    if len(self.hw_desc) > 256:
      return "hw_desc is not of size 256"
    if not isinstance(self.sw_desc, str):
      return "sw_desc is not string"
    if len(self.sw_desc) > 256:
      return "sw_desc is not of size 256"
    if not isinstance(self.serial_num, str):
      return "serial_num is not string"
    if len(self.serial_num) > 32:
      return "serial_num is not of size 32"
    if not isinstance(self.dp_desc, str):
      return "dp_desc is not string"
    if len(self.dp_desc) > 256:
      return "dp_desc is not of size 256"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += self.mfr_desc.ljust(256,'\0')
    packed += self.hw_desc.ljust(256,'\0')
    packed += self.sw_desc.ljust(256,'\0')
    packed += self.serial_num.ljust(32,'\0')
    packed += self.dp_desc.ljust(256,'\0')
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 1056):
      return binaryString
    self.mfr_desc = binaryString[0:256].replace("\0","")
    self.hw_desc = binaryString[256:512].replace("\0","")
    self.sw_desc = binaryString[512:768].replace("\0","")
    self.serial_num = binaryString[768:800].replace("\0","")
    self.dp_desc = binaryString[800:1056].replace("\0","")
    return binaryString[1056:]

  @staticmethod
  def __len__ ():
    return 1056

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.mfr_desc != other.mfr_desc: return False
    if self.hw_desc != other.hw_desc: return False
    if self.sw_desc != other.sw_desc: return False
    if self.serial_num != other.serial_num: return False
    if self.dp_desc != other.dp_desc: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'mfr_desc: ' + str(self.mfr_desc) + '\n'
    outstr += prefix + 'hw_desc: ' + str(self.hw_desc) + '\n'
    outstr += prefix + 'sw_desc: ' + str(self.sw_desc) + '\n'
    outstr += prefix + 'serial_num: ' + str(self.serial_num) + '\n'
    outstr += prefix + 'dp_desc: ' + str(self.dp_desc) + '\n'
    return outstr

ofp_desc_stats_reply = ofp_desc_stats


@openflow_stats_request('OFPST_FLOW', 1)
class ofp_flow_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.match = ofp_match()
    self.table_id = TABLE_ALL
    self.out_port = OFPP_NONE
    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += self.match.pack()
    packed += struct.pack("!BBH", self.table_id, 0, self.out_port)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 44):
      return binaryString
    self.match.unpack(binaryString[0:])
    (self.table_id, pad, self.out_port) = struct.unpack_from("!BBH", binaryString, len(self.match))
    return binaryString[len(self)]

  @staticmethod
  def __len__ ():
    return 4 + len(ofp_match)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.match != other.match: return False
    if self.table_id != other.table_id: return False
    if self.out_port != other.out_port: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'out_port: ' + str(self.out_port) + '\n'
    return outstr


@openflow_stats_reply('OFPST_FLOW', is_list = True)
class ofp_flow_stats (ofp_stats_body_base):
  _MIN_LENGTH = 88
  def __init__ (self, **kw):
    self.table_id = 0
    self.match = ofp_match()
    self.duration_sec = 0
    self.duration_nsec = 0
    self.priority = OFP_DEFAULT_PRIORITY
    self.idle_timeout = 0
    self.hard_timeout = 0
    self.cookie = 0
    self.packet_count = 0
    self.byte_count = 0
    self.actions = []

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!HBB", len(self), self.table_id, 0)
    packed += self.match.pack()
    packed += struct.pack("!LLHHH", self.duration_sec, self.duration_nsec, self.priority, self.idle_timeout, self.hard_timeout)
    packed += _PAD6 # Pad
    packed += struct.pack("!QQQ", self.cookie, self.packet_count, self.byte_count)
    for i in self.actions:
      packed += i.pack()
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 48 + len(self.match)):
      return binaryString
    (length, self.table_id, pad) = struct.unpack_from("!HBB", binaryString, 0)
    self.match.unpack(binaryString[4:])
    (self.duration_sec, self.duration_nsec, self.priority, self.idle_timeout, self.hard_timeout) = struct.unpack_from("!LLHHH", binaryString, 4 + len(self.match))
    (self.cookie, self.packet_count, self.byte_count) = struct.unpack_from("!QQQ", binaryString, 24 + len(self.match))
    self.actions,offset = _unpack_actions(binaryString, length - (48 + len(self.match)), 48 + len(self.match))
    assert offset == length
    return binaryString[offset:]

  def __len__ (self):
    l = 48 + len(self.match)
    for i in self.actions:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if len(self) != len(other): return False
    if self.table_id != other.table_id: return False
    if self.match != other.match: return False
    if self.duration_sec != other.duration_sec: return False
    if self.duration_nsec != other.duration_nsec: return False
    if self.priority != other.priority: return False
    if self.idle_timeout != other.idle_timeout: return False
    if self.hard_timeout != other.hard_timeout: return False
    if self.cookie != other.cookie: return False
    if self.packet_count != other.packet_count: return False
    if self.byte_count != other.byte_count: return False
    if self.actions != other.actions: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'length: ' + str(len(self)) + '\n'
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'duration_sec: ' + str(self.duration_sec) + '\n'
    outstr += prefix + 'duration_nsec: ' + str(self.duration_nsec) + '\n'
    outstr += prefix + 'priority: ' + str(self.priority) + '\n'
    outstr += prefix + 'idle_timeout: ' + str(self.idle_timeout) + '\n'
    outstr += prefix + 'hard_timeout: ' + str(self.hard_timeout) + '\n'
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'packet_count: ' + str(self.packet_count) + '\n'
    outstr += prefix + 'byte_count: ' + str(self.byte_count) + '\n'
    outstr += prefix + 'actions: \n'
    for obj in self.actions:
      outstr += obj.show(prefix + '  ')
    return outstr
ofp_flow_stats_reply = ofp_flow_stats


@openflow_stats_request('OFPST_AGGREGATE', 2)
class ofp_aggregate_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.match = ofp_match()
    self.table_id = TABLE_ALL
    self.out_port = OFPP_NONE

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += self.match.pack()
    packed += struct.pack("!BBH", self.table_id, 0, self.out_port)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 4 + len(self.match)):
      return binaryString
    self.match.unpack(binaryString[0:])
    (self.table_id, pad, self.out_port) = struct.unpack_from("!BBH", binaryString, len(self.match))
    return binaryString[44:]

  @staticmethod
  def __len__ ():
    return 44

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.match != other.match: return False
    if self.table_id != other.table_id: return False
    if self.out_port != other.out_port: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'out_port: ' + str(self.out_port) + '\n'
    return outstr


@openflow_stats_reply('OFPST_AGGREGATE')
class ofp_aggregate_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.packet_count = 0
    self.byte_count = 0
    self.flow_count = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!QQL", self.packet_count, self.byte_count, self.flow_count)
    packed += _PAD4 # Pad
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 24):
      return binaryString
    (self.packet_count, self.byte_count, self.flow_count) = struct.unpack_from("!QQL", binaryString, 0)
    return binaryString[24:]

  @staticmethod
  def __len__ ():
    return 24

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.packet_count != other.packet_count: return False
    if self.byte_count != other.byte_count: return False
    if self.flow_count != other.flow_count: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'packet_count: ' + str(self.packet_count) + '\n'
    outstr += prefix + 'byte_count: ' + str(self.byte_count) + '\n'
    outstr += prefix + 'flow_count: ' + str(self.flow_count) + '\n'
    return outstr
ofp_aggregate_stats_reply = ofp_aggregate_stats


@openflow_stats_reply('OFPST_TABLE', 3, is_list = True)
class ofp_table_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.table_id = 0
    self.name= ""
    self.wildcards = 0
    self.max_entries = 0
    self.active_count = 0
    self.lookup_count = 0
    self.matched_count = 0

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.name, str):
      return "name is not string"
    if len(self.name) > 32:
      return "name is not of size 32"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!B", self.table_id)
    packed += _PAD3
    packed += self.name.ljust(32,'\0')
    packed += struct.pack("!LLLQQ", self.wildcards, self.max_entries, self.active_count, self.lookup_count, self.matched_count)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 64):
      return binaryString
    (self.table_id,) = struct.unpack_from("!B", binaryString, 0)
    self.name = binaryString[4:36].replace("\0","")
    (self.wildcards, self.max_entries, self.active_count, self.lookup_count, self.matched_count) = struct.unpack_from("!LLLQQ", binaryString, 36)
    return binaryString[64:]

  @staticmethod
  def __len__ ():
    return 64

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.table_id != other.table_id: return False
    if self.name != other.name: return False
    if self.wildcards != other.wildcards: return False
    if self.max_entries != other.max_entries: return False
    if self.active_count != other.active_count: return False
    if self.lookup_count != other.lookup_count: return False
    if self.matched_count != other.matched_count: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'name: ' + str(self.name) + '\n'
    outstr += prefix + 'wildcards: ' + str(self.wildcards) + '\n'
    outstr += prefix + 'max_entries: ' + str(self.max_entries) + '\n'
    outstr += prefix + 'active_count: ' + str(self.active_count) + '\n'
    outstr += prefix + 'lookup_count: ' + str(self.lookup_count) + '\n'
    outstr += prefix + 'matched_count: ' + str(self.matched_count) + '\n'
    return outstr
ofp_table_stats_reply = ofp_table_stats


@openflow_stats_request("OFPST_PORT", 4)
class ofp_port_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = OFPP_NONE
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD6
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.port_no,) = struct.unpack_from("!H", binaryString, 0)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    return outstr


@openflow_stats_reply("OFPST_PORT", is_list = True)
class ofp_port_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = 0
    self.rx_packets = 0
    self.tx_packets = 0
    self.rx_bytes = 0
    self.tx_bytes = 0
    self.rx_dropped = 0
    self.tx_dropped = 0
    self.rx_errors = 0
    self.tx_errors = 0
    self.rx_frame_err = 0
    self.rx_over_err = 0
    self.rx_crc_err = 0
    self.collisions = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD6
    packed += struct.pack("!QQQQQQQQQQQQ", self.rx_packets, self.tx_packets, self.rx_bytes, self.tx_bytes, self.rx_dropped, self.tx_dropped, self.rx_errors, self.tx_errors, self.rx_frame_err, self.rx_over_err, self.rx_crc_err, self.collisions)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 104):
      return binaryString
    (self.port_no,) = struct.unpack_from("!H", binaryString, 0)
    (self.rx_packets, self.tx_packets, self.rx_bytes, self.tx_bytes, self.rx_dropped, self.tx_dropped, self.rx_errors, self.tx_errors, self.rx_frame_err, self.rx_over_err, self.rx_crc_err, self.collisions) = struct.unpack_from("!QQQQQQQQQQQQ", binaryString, 8)
    return binaryString[104:]

  @staticmethod
  def __len__ ():
    return 104

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.rx_packets != other.rx_packets: return False
    if self.tx_packets != other.tx_packets: return False
    if self.rx_bytes != other.rx_bytes: return False
    if self.tx_bytes != other.tx_bytes: return False
    if self.rx_dropped != other.rx_dropped: return False
    if self.tx_dropped != other.tx_dropped: return False
    if self.rx_errors != other.rx_errors: return False
    if self.tx_errors != other.tx_errors: return False
    if self.rx_frame_err != other.rx_frame_err: return False
    if self.rx_over_err != other.rx_over_err: return False
    if self.rx_crc_err != other.rx_crc_err: return False
    if self.collisions != other.collisions: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def __add__(self, other):
    if type(self) != type(other): raise NotImplemented()
    return ofp_port_stats(
        port_no=OFPP_NONE,
        rx_packets = self.rx_packets + other.rx_packets,
        tx_packets = self.tx_packets + other.tx_packets,
        rx_bytes = self.rx_bytes + other.rx_bytes,
        tx_bytes = self.tx_bytes + other.tx_bytes,
        rx_dropped = self.rx_dropped + other.rx_dropped,
        tx_dropped = self.tx_dropped + other.tx_dropped,
        rx_errors = self.rx_errors + other.rx_errors,
        tx_errors = self.tx_errors + other.tx_errors,
        rx_frame_err = self.rx_frame_err + other.rx_frame_err,
        rx_over_err = self.rx_over_err + other.rx_over_err,
        rx_crc_err = self.rx_crc_err + other.rx_crc_err,
        collisions = self.collisions + other.collisions)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'rx_packets: ' + str(self.rx_packets) + '\n'
    outstr += prefix + 'tx_packets: ' + str(self.tx_packets) + '\n'
    outstr += prefix + 'rx_bytes: ' + str(self.rx_bytes) + '\n'
    outstr += prefix + 'tx_bytes: ' + str(self.tx_bytes) + '\n'
    outstr += prefix + 'rx_dropped: ' + str(self.rx_dropped) + '\n'
    outstr += prefix + 'tx_dropped: ' + str(self.tx_dropped) + '\n'
    outstr += prefix + 'rx_errors: ' + str(self.rx_errors) + '\n'
    outstr += prefix + 'tx_errors: ' + str(self.tx_errors) + '\n'
    outstr += prefix + 'rx_frame_err: ' + str(self.rx_frame_err) + '\n'
    outstr += prefix + 'rx_over_err: ' + str(self.rx_over_err) + '\n'
    outstr += prefix + 'rx_crc_err: ' + str(self.rx_crc_err) + '\n'
    outstr += prefix + 'collisions: ' + str(self.collisions) + '\n'
    return outstr
ofp_port_stats_reply = ofp_port_stats


@openflow_stats_request("OFPST_QUEUE", 5)
class ofp_queue_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = 0
    self.queue_id = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD2
    packed += struct.pack("!L", self.queue_id)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    (self.port_no,) = struct.unpack_from("!H", binaryString, 0)
    (self.queue_id,) = struct.unpack_from("!L", binaryString, 4)
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.queue_id != other.queue_id: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    return outstr


@openflow_stats_reply("OFPST_QUEUE", is_list = True)
class ofp_queue_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = 0
    self.queue_id = 0
    self.tx_bytes = 0
    self.tx_packets = 0
    self.tx_errors = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD2
    packed += struct.pack("!LQQQ", self.queue_id, self.tx_bytes, self.tx_packets, self.tx_errors)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 32):
      return binaryString
    (self.port_no,) = struct.unpack_from("!H", binaryString, 0)
    (self.queue_id, self.tx_bytes, self.tx_packets, self.tx_errors) = struct.unpack_from("!LQQQ", binaryString, 4)
    return binaryString[32:]

  @staticmethod
  def __len__ ():
    return 32

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.queue_id != other.queue_id: return False
    if self.tx_bytes != other.tx_bytes: return False
    if self.tx_packets != other.tx_packets: return False
    if self.tx_errors != other.tx_errors: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    outstr += prefix + 'tx_bytes: ' + str(self.tx_bytes) + '\n'
    outstr += prefix + 'tx_packets: ' + str(self.tx_packets) + '\n'
    outstr += prefix + 'tx_errors: ' + str(self.tx_errors) + '\n'
    return outstr
ofp_queue_stats_reply = ofp_queue_stats


@openflow_stats_reply("OFPST_VENDOR", 65535, is_list = False)
#FIXME
class ofp_vendor_stats_generic (ofp_stats_body_base):
  def __init__ (self, **kw):

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD2
    packed += struct.pack("!LQQQ", self.queue_id, self.tx_bytes, self.tx_packets, self.tx_errors)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 32):
      return binaryString
    (self.port_no,) = struct.unpack_from("!H", binaryString, 0)
    (self.queue_id, self.tx_bytes, self.tx_packets, self.tx_errors) = struct.unpack_from("!LQQQ", binaryString, 4)
    return binaryString[32:]

  @staticmethod
  def __len__ ():
    return 32

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.queue_id != other.queue_id: return False
    if self.tx_bytes != other.tx_bytes: return False
    if self.tx_packets != other.tx_packets: return False
    if self.tx_errors != other.tx_errors: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    return outstr


@openflow_c_message("OFPT_PACKET_OUT", 13)
class ofp_packet_out (ofp_header):
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self._buffer_id = NO_BUFFER
    self.in_port = OFPP_NONE
    self.actions = []
    self._data = b''

    # ofp_flow_mod & ofp_packet_out do some special handling of 'actions'

    # Allow "action" as a synonym for "actions"
    if 'action' in kw and 'actions' not in kw:
      kw['actions'] = kw['action']
      del kw['action']
    initHelper(self, kw)

    # Allow use of actions=<a single action> for kw args.
    if not hasattr(self.actions, '__getitem__'):
      self.actions = [self.actions]

  @property
  def buffer_id (self):
    if self._buffer_id == NO_BUFFER: return None
    return self._buffer_id
  @buffer_id.setter
  def buffer_id (self, val):
    if val is None: val = NO_BUFFER
    self._buffer_id = val

  @property
  def data (self):
    return self._data
  @data.setter
  def data (self, data):
    if data is None:
      self._data = b''
    elif isinstance(data, packet_base):
      self._data = data.pack()
    elif isinstance(data, ofp_packet_in):
      # Enable you to easily resend a packet
      self._data = b''
      self.buffer_id = data.buffer_id
      if self.buffer_id is None:
        #TODO: It'd be nice to log and then ignore if data is incomplete
        #      Unfortunately, we currently have no logging in here, so we
        #      assert instead which is a either too drastic or too quiet.
        assert data.is_complete
        self._data = data._data
      self.in_port = data.in_port
    elif isinstance(data, bytes):
      self._data = data
    assert assert_type("data", self._data, (bytes,))

  def _validate (self):
    if self.buffer_id is not None and self.data != b'':
      return "can not have both buffer_id and data set"
    return None

  def pack (self):
    assert self._assert()

    actions = b''.join((i.pack() for i in self.actions))
    actions_len = len(actions)

    if self.data is not None:
      return b''.join((ofp_header.pack(self),
        struct.pack("!LHH", self._buffer_id, self.in_port, actions_len),
        actions, self.data))
    else:
      return b''.join((ofp_header.pack(self),
      struct.pack("!LHH", self._buffer_id, self.in_port, actions_len),
      actions))

  def unpack (self, binaryString):
    if (len(binaryString) < 16):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self._buffer_id, self.in_port, actions_len) = struct.unpack_from("!LHH", binaryString, 8)
    self.actions,offset = _unpack_actions(binaryString, actions_len, 16)

    self.data = binaryString[offset:self._length] if offset < self._length else None
    return binaryString[self._length:]

  def __len__ (self):
    return 16 + reduce(operator.add, (len(a) for a in self.actions),
        0) + (len(self.data) if self.data else 0)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.buffer_id != other.buffer_id: return False
    if self.in_port != other.in_port: return False
    if self.actions != other.actions: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'buffer_id: ' + str(self.buffer_id) + '\n'
    outstr += prefix + 'in_port: ' + str(self.in_port) + '\n'
    outstr += prefix + 'actions_len: ' + str(len(self.actions)) + '\n'
    outstr += prefix + 'actions: \n'
    for obj in self.actions:
      if obj is None:
        raise RuntimeError("An element of self.actions was None! "
                           + "Bad formatting...")
      outstr += obj.show(prefix + '  ')
    return outstr


##3.7 Barrier Message
@openflow_s_message("OFPT_BARRIER_REPLY", 21,
    reply_to="ofp_barrier_request")
class ofp_barrier_reply (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_s_message("OFPT_BARRIER_REQUEST", 20,
    request_for="ofp_barrier_reply")
class ofp_barrier_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


#4 Asynchronous Messages
@openflow_s_message("OFPT_PACKET_IN", 10)
class ofp_packet_in (ofp_header):
  _MIN_LENGTH = 18
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    self.in_port = OFPP_NONE
    self._buffer_id = NO_BUFFER
    self.reason = 0
    self.data = None
    self._total_len = None

    if 'total_len' in kw:
      self._total_len = kw.pop('total_len')

    initHelper(self, kw)

  def _validate (self):
    if self.data and (self.total_len < len(self.data)):
      return "total len less than data len"

  @property
  def total_len (self):
    if self._total_len is None:
      return len(self.data) if self.data else 0
    return self._total_len

  @total_len.setter
  def total_len (self, value):
    self._total_len = value

  @property
  def buffer_id (self):
    if self._buffer_id == NO_BUFFER: return None
    return self._buffer_id
  @buffer_id.setter
  def buffer_id (self, val):
    if val is None: val = NO_BUFFER
    self._buffer_id = val

  @property
  def data (self):
    return self._data
  @data.setter
  def data (self, data):
    assert assert_type("data", data, (packet_base, str))
    if data is None:
      self._data = ''
    elif isinstance(data, packet_base):
      self._data = data.pack()
    else:
      self._data = data

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!LHHBB", self._buffer_id, self.total_len, self.in_port, self.reason, 0)
    packed += self.data
    return packed

  @property
  def is_complete (self):
    if self.buffer_id is not None: return True
    return len(self.data) == self.total_len

  def unpack (self, binaryString):
    if (len(binaryString) < 18):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self._buffer_id, self._total_len, self.in_port, self.reason, pad) = struct.unpack_from("!LHHBB", binaryString, 8)
    if (len(binaryString) < self._length):
      return binaryString
    self.data = binaryString[18:self._length]
    return binaryString[self._length:]

  def __len__ (self):
    return 18 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.buffer_id != other.buffer_id: return False
    if self.total_len != other.total_len: return False
    if self.in_port != other.in_port: return False
    if self.reason != other.reason: return False
    if self.data != other.data: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'buffer_id: ' + str(self.buffer_id) + '\n'
    outstr += prefix + 'total_len: ' + str(self._total_len) + '\n'
    outstr += prefix + 'in_port: ' + str(self.in_port) + '\n'
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'data: ' + str(self.data) + '\n'
    return outstr


@openflow_s_message("OFPT_FLOW_REMOVED", 11)
class ofp_flow_removed (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.match = ofp_match()
    self.cookie = 0
    self.priority = 0
    self.reason = 0
    self.duration_sec = 0
    self.duration_nsec = 0
    self.idle_timeout = 0
    self.packet_count = 0
    self.byte_count = 0
    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += self.match.pack()
    packed += struct.pack("!QHB", self.cookie, self.priority, self.reason)
    packed += _PAD
    packed += struct.pack("!LLH", self.duration_sec, self.duration_nsec, self.idle_timeout)
    packed += _PAD2
    packed += struct.pack("!QQ", self.packet_count, self.byte_count)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < len(self)):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    self.match.unpack(binaryString[8:])
    (self.cookie, self.priority, self.reason) = struct.unpack_from("!QHB", binaryString, 8 + len(self.match))
    (self.duration_sec, self.duration_nsec, self.idle_timeout) = struct.unpack_from("!LLH", binaryString, 20 + len(self.match))
    (self.packet_count, self.byte_count) = struct.unpack_from("!QQ", binaryString, 32 + len(self.match))
    return binaryString[len(self):]

  @staticmethod
  def __len__ ():
    return 48 + len(ofp_match)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.match != other.match: return False
    if self.cookie != other.cookie: return False
    if self.priority != other.priority: return False
    if self.reason != other.reason: return False
    if self.duration_sec != other.duration_sec: return False
    if self.duration_nsec != other.duration_nsec: return False
    if self.idle_timeout != other.idle_timeout: return False
    if self.packet_count != other.packet_count: return False
    if self.byte_count != other.byte_count: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'priority: ' + str(self.priority) + '\n'
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'duration_sec: ' + str(self.duration_sec) + '\n'
    outstr += prefix + 'duration_nsec: ' + str(self.duration_nsec) + '\n'
    outstr += prefix + 'idle_timeout: ' + str(self.idle_timeout) + '\n'
    outstr += prefix + 'packet_count: ' + str(self.packet_count) + '\n'
    outstr += prefix + 'byte_count: ' + str(self.byte_count) + '\n'
    return outstr


@openflow_s_message("OFPT_PORT_STATUS", 12)
class ofp_port_status (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.reason = 0
    self.desc = ofp_phy_port()

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.desc, ofp_phy_port):
      return "desc is not class ofp_phy_port"
    return None

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!B", self.reason)
    packed += _PAD * 7 # Pad
    packed += self.desc.pack()
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 64):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.reason,) = struct.unpack_from("!B", binaryString, 8)
    self.desc.unpack(binaryString[16:])
    return binaryString[64:]

  @staticmethod
  def __len__ ():
    return 64

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.reason != other.reason: return False
    if self.desc != other.desc: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'desc: \n'
    outstr += self.desc.show(prefix + '  ')
    return outstr


@openflow_s_message("OFPT_ERROR", 1)
class ofp_error (ofp_header):
  _MIN_LENGTH = 12
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.type = 0
    self.code = 0
    self.data = []

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.type, self.code)
    for i in self.data:
      packed += struct.pack("!B",i)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.type, self.code) = struct.unpack_from("!HH", binaryString, 8)
    return binaryString[12:]

  def __len__ (self):
    return 12 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.type != other.type: return False
    if self.code != other.code: return False
    if self.data != other.data: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    t = self.type
    c = self.code
    if t < len(ofp_error_type):
      n = ofp_error_type_map[t]
      t = "%s (%i)" % (n, t)
      n = 'ofp' + n.lower()[5:] + '_code_map'
      if n in sys.modules[__name__].__dict__:
        if c in sys.modules[__name__].__dict__[n]:
          c = "%s (%i)" % (sys.modules[__name__].__dict__[n][c], c)
    outstr += prefix + 'type: ' + str(t) + '\n'
    outstr += prefix + 'code: ' + str(c) + '\n'
    if len(self.data):
      outstr += prefix + 'data: ' + str(self.data) + '\n'
    return outstr.strip()


#5. Symmetric Messages
@openflow_sc_message("OFPT_HELLO", 0)
class ofp_hello (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_sc_message("OFPT_ECHO_REQUEST", 2,
    request_for="ofp_echo_reply")
class ofp_echo_request (ofp_header):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.body = b''
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += self.body
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    # Note that we trust the header to be correct here
    if len(binaryString) < self._length:
      return binaryString
    l = self._length - 8
    self.body = binaryString[8:8+l]
    return binaryString[8 + l:]

  def __len__ (self):
    return 8 + len(self.body)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.body != other.body: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


@openflow_sc_message("OFPT_ECHO_REPLY", 3,
    reply_to="ofp_echo_request")
class ofp_echo_reply (ofp_header):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.body = b''
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += self.body
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    # Note that we trust the header to be correct here
    if len(binaryString) < self._length:
      return binaryString
    l = self._length - 8
    self.body = binaryString[8:8+l]
    return binaryString[8 + l:]

  def __len__ (self):
    return 8 + len(self.body)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.body != other.body: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


class ofp_vendor_header (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.header_type = OFPT_VENDOR
    self.vendor = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!L", self.vendor)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.vendor,) = struct.unpack_from("!L", binaryString, 8)
    return binaryString[12:]

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.vendor != other.vendor: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'vendor: ' + str(self.vendor) + '\n'
    return outstr


@openflow_sc_message("OFPT_VENDOR", 4)
class ofp_vendor (ofp_header):
  _MIN_LENGTH = 12
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.vendor = 0
    self.data = b''
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!L", self.vendor)
    if hasattr(self.data, "pack"):
      packed += self.data.pack()
    else:
      packed += self.data
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.vendor,) = struct.unpack_from("!L", binaryString, 8)
    if len(binaryString) < self._length:
      return binaryString
    self.data = binaryString[12:self._length]
    return binaryString[self._length:]

  def __len__ (self):
    return 12 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.vendor != other.vendor: return False
    if self.data != other.data: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'vendor: ' + str(self.vendor) + '\n'
    outstr += prefix + 'data: ' + self.data + '\n'
    return outstr


@openflow_c_message("OFPT_FEATURES_REQUEST", 5,
    request_for="ofp_features_reply")
class ofp_features_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_c_message("OFPT_GET_CONFIG_REQUEST", 7,
    request_for="ofp_get_config_reply")
class ofp_get_config_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 8):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    return binaryString[8:]

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_s_message("OFPT_GET_CONFIG_REPLY", 8,
    reply_to="ofp_get_config_request")
class ofp_get_config_reply (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.flags = 0
    self.miss_send_len = OFP_DEFAULT_MISS_SEND_LEN

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.flags, self.miss_send_len)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.flags, self.miss_send_len) = \
        struct.unpack_from("!HH", binaryString, 8)
    return binaryString[12:]

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.flags != other.flags: return False
    if self.miss_send_len != other.miss_send_len: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'miss_send_len: ' + str(self.miss_send_len) + '\n'
    return outstr


@openflow_c_message("OFPT_SET_CONFIG", 9)
class ofp_set_config (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.flags = 0
    self.miss_send_len = OFP_DEFAULT_MISS_SEND_LEN

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = ""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.flags, self.miss_send_len)
    return packed

  def unpack (self, binaryString):
    if (len(binaryString) < 12):
      return binaryString
    ofp_header.unpack(self, binaryString[0:])
    (self.flags, self.miss_send_len) = \
        struct.unpack_from("!HH", binaryString, 8)
    return binaryString[12:]

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.flags != other.flags: return False
    if self.miss_send_len != other.miss_send_len: return False
    return True

  def __ne__ (self, other): return not self.__eq__(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'miss_send_len: ' + str(self.miss_send_len) + '\n'
    return outstr


def _get_type (o):
  """
  Gets the OpenFlow type for the given class or object.

  If the given class/object is not an OpenFlow type,
  returns None.

  For example, if o is an ofp_flow_mod, it returns
  OFPT_FLOW_MOD (14).
  """
  #TODO: Replace with a more efficient version.  A
  #      good way to do this might be to set a class
  #      variable __type on initialization.
  if o.__class__ is object:
    c = o.__name__
  else:
    c = o.__class__.__name__
  if not c.startswith("ofp_"): return None
  c = c.split("ofp_", 1)[1]
  if (c.endswith("_stats_request") or c.endswith("_stats_reply") or
      c.endswith("_stats")):
    c = c.rsplit("_stats", 1)[0].upper()
    c = "OFPST_" + c
    return ofp_stats_type_rev_map.get(c)
  #TODO: For non-stats


def _unpack_actions (b, length, offset=0):
  """
  Parses actions from a buffer
  b is a buffer (bytes)
  offset, if specified is where in b to start decoding
  returns ([Actions], next_offset)
  """
  if (len(b) - offset) < length: return ([], offset)
  actions = []
  end = length + offset
  while offset < end:
    (t,l) = struct.unpack_from("!HH", b, offset)
    if (len(b) - offset) < l: return ([], offset)
    a = _action_type_to_class.get(t)
    if a is None:
      # Use generic action header for unknown type
      a = ofp_action_generic()
    else:
      a = a()
    a.unpack(b[offset:offset+l])
    assert len(a) == l
    actions.append(a)
    offset += l
  return (actions, offset)

def _init ():
  def formatMap (name, m):
    o = name + " = {\n"
    vk = sorted([(v,k) for k,v in m.iteritems()])
    maxlen = 2 + len(reduce(lambda a,b: a if len(a)>len(b) else b,
                            (v for k,v in vk)))
    fstr = "  %-" + str(maxlen) + "s : %s,\n"
    for v,k in vk:
      o += fstr % ("'" + k + "'",v)
    o += "}"
    return o
  """
  maps = []
  for k,v in globals().iteritems():
    if k.startswith("ofp_") and k.endswith("_map") and type(v) == dict:
      maps.append((k,v))
  for name,m in maps:
    rev = {}
    name = name[:-4]
    names = globals()[name]
    for n in names:
      rev[n] = globals()[n]

    globals()[name + '_rev_map'] = rev
    print formatMap(name + "_rev_map", rev)
  return
  """
  maps = []
  for k,v in globals().iteritems():
    if (k.startswith("ofp_") and k.endswith("_rev_map")
        and type(v) == dict):
      maps.append((k[:-8],v))
  for name,m in maps:
    # Try to generate forward maps
    forward = dict(((v,k) for k,v in m.iteritems()))
    if len(forward) == len(m):
      if name + "_map" not in globals():
        globals()[name + "_map"] = forward
    else:
      print name + "_rev_map is not a map"

    # Try to generate lists
    v = m.values()
    v.sort()
    if v[-1] != len(v)-1:
      # Allow ones where the last value is a special value (e.g., VENDOR)
      del v[-1]
    if len(v) > 0 and v[0] == 0 and v[-1] == len(v)-1:
      globals()[name] = v

    # Generate gobals
    for k,v in m.iteritems():
      globals()[k] = v


_init()


# Values from macro definitions
OFP_FLOW_PERMANENT = 0
OFP_DL_TYPE_ETH2_CUTOFF = 0x0600
DESC_STR_LEN = 256
OFPFW_ICMP_CODE = OFPFW_TP_DST
OFPQ_MIN_RATE_UNCFG = 0xffff
OFP_VERSION = 0x02
OFP_MAX_TABLE_NAME_LEN = 32
OFP_DL_TYPE_NOT_ETH_TYPE = 0x05ff
OFP_DEFAULT_MISS_SEND_LEN = 128
OFP_MAX_PORT_NAME_LEN = 16
OFP_SSL_PORT = 6633
OFPFW_ICMP_TYPE = OFPFW_TP_SRC
OFP_TCP_PORT = 6633
SERIAL_NUM_LEN = 32
OFP_DEFAULT_PRIORITY = 0x8000
OFP_VLAN_NONE = 0xffff
OFPQ_ALL = 0xffffffff

ofp_match_data = {
  'in_port' : (0, OFPFW_IN_PORT),
  'dl_src' : (EMPTY_ETH, OFPFW_DL_SRC),
  'dl_dst' : (EMPTY_ETH, OFPFW_DL_DST),
  'dl_vlan' : (0, OFPFW_DL_VLAN),
  'dl_vlan_pcp' : (0, OFPFW_DL_VLAN_PCP),
  'dl_type' : (0, OFPFW_DL_TYPE),
  'nw_tos' : (0, OFPFW_NW_TOS),
  'nw_proto' : (0, OFPFW_NW_PROTO),
  'nw_src' : (0, OFPFW_NW_SRC_ALL),
  'nw_dst' : (0, OFPFW_NW_DST_ALL),
  'tp_src' : (0, OFPFW_TP_SRC),
  'tp_dst' : (0, OFPFW_TP_DST),
}
